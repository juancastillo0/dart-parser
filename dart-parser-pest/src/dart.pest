LetExpression = {("let" ~ StaticFinalDeclarationList ~ "in" ~ Expression)}

FinalConstVarOrTypeFinalToken = {(("late")? ~ "final" ~ (Type)?)}

FinalConstVarOrTypeConstToken = {("const" ~ (Type)?)}

FinalConstVarOrTypeVarOrType = {(("late")? ~ VarOrType)}

FinalConstVarOrType = {(FinalConstVarOrTypeFinalToken | FinalConstVarOrTypeConstToken | FinalConstVarOrTypeVarOrType)}

VarOrType = {("var" | Type)}

ExpressionEqual = {("=" ~ Expression)}

InitializedIdentifierItem = {("," ~ InitializedIdentifier)}

InitializedVariableDeclaration = {(DeclaredIdentifier ~ (ExpressionEqual)? ~ (InitializedIdentifierItem)*)}

InitializedIdentifier = {(Identifier ~ (("=" ~ Expression))?)}

InitializedIdentifierList = {(InitializedIdentifier ~ (("," ~ InitializedIdentifier))*)}

FunctionSignature = {((Type)? ~ Identifier ~ FormalParameterPart)}

FormalParameterPart = {((TypeParameters)? ~ FormalParameterList)}

FunctionBodyArrowToken = {(("async")? ~ "=>" ~ Expression ~ ";")}

FunctionBodyGeneratorAsyncToken = {("async" ~ ("*")?)}

FunctionBodyGeneratorSyncToken = {("sync" ~ "*")}

FunctionBodyGenerator = {(FunctionBodyGeneratorAsyncToken | FunctionBodyGeneratorSyncToken)}

FunctionBodyBlock = {((FunctionBodyGenerator)? ~ Block)}

FunctionBody = {(FunctionBodyArrowToken | FunctionBodyBlock)}

Block = {("{" ~ Statements ~ "}")}

EmptyParameters = {("(" ~ ")")}

FormalParameterListNormalFormalParameters = {("(" ~ NormalFormalParameters ~ (",")? ~ ")")}

NormalWithOptionalOrNamedParameters = {("(" ~ NormalFormalParameters ~ "," ~ OptionalOrNamedFormalParameters ~ ")")}

FormalParameterListOptionalOrNamedFormalParameters = {("(" ~ OptionalOrNamedFormalParameters ~ ")")}

FormalParameterList = {(EmptyParameters | FormalParameterListNormalFormalParameters | NormalWithOptionalOrNamedParameters | FormalParameterListOptionalOrNamedFormalParameters)}

NormalFormalParameterItem = {("," ~ NormalFormalParameter)}

NormalFormalParameters = {(NormalFormalParameter ~ (NormalFormalParameterItem)*)}

OptionalOrNamedFormalParameters = {(OptionalPositionalFormalParameters | NamedFormalParameters)}

DefaultFormalParameterItem = {("," ~ DefaultFormalParameter)}

OptionalPositionalFormalParameters = {("[" ~ DefaultFormalParameter ~ (DefaultFormalParameterItem)* ~ (",")? ~ "]")}

DefaultNamedParameterItem = {("," ~ DefaultNamedParameter)}

NamedFormalParameters = {("{" ~ DefaultNamedParameter ~ (DefaultNamedParameterItem)* ~ (",")? ~ "}")}

NormalFormalParameter = {(Metadata ~ NormalFormalParameterNoMetadata)}

NormalFormalParameterNoMetadata = {(FunctionFormalParameter | FieldFormalParameter | SimpleFormalParameter)}

FunctionFormalParameter = {(("covariant")? ~ (Type)? ~ Identifier ~ FormalParameterPart ~ ("?")?)}

SimpleFormalParameterIdentifier = {(("covariant")? ~ Identifier)}

SimpleFormalParameter = {(DeclaredIdentifier | SimpleFormalParameterIdentifier)}

DeclaredIdentifier = {(("covariant")? ~ FinalConstVarOrType ~ Identifier)}

FieldFormalParameterFormalParameterPart = {(FormalParameterPart ~ ("?")?)}

FieldFormalParameter = {((FinalConstVarOrType)? ~ "this" ~ "." ~ Identifier ~ (FieldFormalParameterFormalParameterPart)?)}

DefaultFormalParameter = {(NormalFormalParameter ~ (("=" ~ Expression))?)}

EqualTokenOrColonToken = {("=" | ":")}

DefaultNamedParameterAssignment = {(EqualTokenOrColonToken ~ Expression)}

DefaultNamedParameter = {(Metadata ~ ("required")? ~ NormalFormalParameterNoMetadata ~ (DefaultNamedParameterAssignment)?)}

ClassDeclarationMembers = {(Metadata ~ ClassMemberDeclaration)}

ClassDeclarationClassToken = {(("abstract")? ~ "class" ~ TypeIdentifier ~ (TypeParameters)? ~ (Superclass)? ~ (Interfaces)? ~ "{" ~ (ClassDeclarationMembers)* ~ "}")}

ClassDeclarationMixin = {(("abstract")? ~ "class" ~ MixinApplicationClass)}

ClassDeclaration = {(ClassDeclarationClassToken | ClassDeclarationMixin)}

TypeNotVoidItem = {("," ~ TypeNotVoid)}

TypeNotVoidList = {(TypeNotVoid ~ (TypeNotVoidItem)*)}

ClassMemberDeclarationSemicolonToken = {(Declaration ~ ";")}

ClassMemberDeclarationMethodSignature = {(MethodSignature ~ FunctionBody)}

ClassMemberDeclaration = {(ClassMemberDeclarationSemicolonToken | ClassMemberDeclarationMethodSignature)}

MethodSignatureConstructorSignature = {(ConstructorSignature ~ (Initializers)?)}

MethodSignatureFunctionSignature = {(("static")? ~ FunctionSignature)}

MethodSignatureGetterSignature = {(("static")? ~ GetterSignature)}

MethodSignatureSetterSignature = {(("static")? ~ SetterSignature)}

MethodSignature = {(MethodSignatureConstructorSignature | FactoryConstructorSignature | MethodSignatureFunctionSignature | MethodSignatureGetterSignature | MethodSignatureSetterSignature | OperatorSignature)}

DeclarationFactoryConstructorSignature = {("external" ~ FactoryConstructorSignature)}

ExternalConstantConstructorSignature = {("external" ~ ConstantConstructorSignature)}

ExternalConstructorSignature = {("external" ~ ConstructorSignature)}

ExternalMaybeStatic = {("external" ~ ("static")?)}

DeclarationGetterSignature = {((ExternalMaybeStatic)? ~ GetterSignature)}

DeclarationSetterSignature = {((("external" ~ ("static")?))? ~ SetterSignature)}

DeclarationFunctionSignature = {((("external" ~ ("static")?))? ~ FunctionSignature)}

DeclarationOperatorSignature = {(("external")? ~ OperatorSignature)}

StaticConst = {("static" ~ "const" ~ (Type)? ~ StaticFinalDeclarationList)}

StaticFinal = {("static" ~ "final" ~ (Type)? ~ StaticFinalDeclarationList)}

StaticLateFinal = {("static" ~ "late" ~ "final" ~ (Type)? ~ InitializedIdentifierList)}

StaticVarOrType = {("static" ~ ("late")? ~ VarOrType ~ InitializedIdentifierList)}

CovariantLateFinal = {("covariant" ~ "late" ~ "final" ~ (Type)? ~ IdentifierList)}

CovariantVarOrType = {("covariant" ~ ("late")? ~ VarOrType ~ InitializedIdentifierList)}

DeclarationFinalToken = {(("late")? ~ "final" ~ (Type)? ~ InitializedIdentifierList)}

DeclarationVarOrType = {(("late")? ~ VarOrType ~ InitializedIdentifierList)}

RedirectionOrInitializers = {(Redirection | Initializers)}

DeclarationConstantConstructorSignature = {(ConstantConstructorSignature ~ (RedirectionOrInitializers)?)}

DeclarationConstructorSignature = {(ConstructorSignature ~ ((Redirection | Initializers))?)}

Declaration = {(DeclarationFactoryConstructorSignature | ExternalConstantConstructorSignature | ExternalConstructorSignature | DeclarationGetterSignature | DeclarationSetterSignature | DeclarationFunctionSignature | DeclarationOperatorSignature | StaticConst | StaticFinal | StaticLateFinal | StaticVarOrType | CovariantLateFinal | CovariantVarOrType | DeclarationFinalToken | DeclarationVarOrType | RedirectingFactoryConstructorSignature | DeclarationConstantConstructorSignature | DeclarationConstructorSignature)}

StaticFinalDeclarationItem = {("," ~ StaticFinalDeclaration)}

StaticFinalDeclarationList = {(StaticFinalDeclaration ~ (StaticFinalDeclarationItem)*)}

StaticFinalDeclaration = {(Identifier ~ "=" ~ Expression)}

OperatorSignature = {((Type)? ~ "operator" ~ Operator ~ FormalParameterList)}

Operator = {("~" | BinaryOperator | "[]" | "[]=")}

BinaryOperator = {(MultiplicativeOperator | AdditiveOperator | ShiftOperator | RelationalOperator | "==" | BitwiseOperator)}

GetterSignature = {((Type)? ~ "get" ~ Identifier)}

SetterSignature = {((Type)? ~ "set" ~ Identifier ~ FormalParameterList)}

ConstructorSignature = {(ConstructorName ~ FormalParameterList)}

IdentifierSelector = {("." ~ Identifier)}

ConstructorName = {(TypeIdentifier ~ (IdentifierSelector)?)}

Redirection = {(":" ~ "this" ~ (("." ~ Identifier))? ~ Arguments)}

InitializerListEntryItem = {("," ~ InitializerListEntry)}

Initializers = {(":" ~ InitializerListEntry ~ (InitializerListEntryItem)*)}

InitializerListEntryArguments = {("super" ~ Arguments)}

InitializerListEntrySuperToken = {("super" ~ "." ~ Identifier ~ Arguments)}

InitializerListEntry = {(InitializerListEntryArguments | InitializerListEntrySuperToken | FieldInitializer | Assertion)}

FieldInitializerThisToken = {("this" ~ ".")}

FieldInitializer = {((FieldInitializerThisToken)? ~ Identifier ~ "=" ~ InitializerExpression)}

InitializerExpression = {(ConditionalExpression | Cascade)}

FactoryConstructorSignature = {(("const")? ~ "factory" ~ ConstructorName ~ FormalParameterList)}

RedirectingFactoryConstructorSignature = {(("const")? ~ "factory" ~ ConstructorName ~ FormalParameterList ~ "=" ~ ConstructorDesignation)}

ConstructorDesignationTypeName = {(TypeName ~ TypeArguments ~ (("." ~ Identifier))?)}

ConstructorDesignation = {(TypeIdentifier | QualifiedName | ConstructorDesignationTypeName)}

ConstantConstructorSignature = {("const" ~ ConstructorName ~ FormalParameterList)}

SuperclassTypeNotVoid = {("extends" ~ TypeNotVoid ~ (Mixins)?)}

Superclass = {(SuperclassTypeNotVoid | Mixins)}

Mixins = {("with" ~ TypeNotVoidList)}

Interfaces = {("implements" ~ TypeNotVoidList)}

MixinApplicationClass = {(Identifier ~ (TypeParameters)? ~ "=" ~ MixinApplication ~ ";")}

MixinApplication = {(TypeNotVoid ~ Mixins ~ (Interfaces)?)}

TypeNotVoidListOn = {("on" ~ TypeNotVoidList)}

MixinDeclarationMetadata = {(Metadata ~ ClassMemberDeclaration)}

MixinDeclaration = {("mixin" ~ TypeIdentifier ~ (TypeParameters)? ~ (TypeNotVoidListOn)? ~ (Interfaces)? ~ "{" ~ (MixinDeclarationMetadata)* ~ "}")}

ExtensionDeclarationMetadata = {(Metadata ~ ClassMemberDeclaration)}

ExtensionDeclaration = {("extension" ~ (Identifier)? ~ (TypeParameters)? ~ "on" ~ Type ~ "{" ~ (ExtensionDeclarationMetadata)* ~ "}")}

EnumEntryItem = {("," ~ EnumEntry)}

EnumType = {("enum" ~ Identifier ~ "{" ~ EnumEntry ~ (EnumEntryItem)* ~ (",")? ~ "}")}

EnumEntry = {(Metadata ~ Identifier)}

TypeNotVoidExtends = {("extends" ~ TypeNotVoid)}

TypeParameter = {(Metadata ~ Identifier ~ (TypeNotVoidExtends)?)}

TypeParameterItem = {("," ~ TypeParameter)}

TypeParameters = {("<" ~ TypeParameter ~ (TypeParameterItem)* ~ ">")}

MetadataItem = {("@" ~ Metadatum)}

Metadata = {(MetadataItem)*}

MetadatumConstructorDesignation = {(ConstructorDesignation ~ Arguments)}

Metadatum = {(Identifier | QualifiedName | MetadatumConstructorDesignation)}

ExpressionAssignableExpression = {(AssignableExpression ~ AssignmentOperator ~ Expression)}

Expression = {(ExpressionAssignableExpression | ConditionalExpression | Cascade | ThrowExpression)}

ExpressionWithoutCascadeAssignableExpression = {(AssignableExpression ~ AssignmentOperator ~ ExpressionWithoutCascade)}

ExpressionWithoutCascade = {(ExpressionWithoutCascadeAssignableExpression | ConditionalExpression | ThrowExpressionWithoutCascade)}

ExpressionItem = {("," ~ Expression)}

ExpressionList = {(Expression ~ (ExpressionItem)*)}

PrimaryUnconditionalAssignableSelector = {("super" ~ UnconditionalAssignableSelector)}

PrimaryArgumentPart = {("super" ~ ArgumentPart)}

PrimaryExpression = {("(" ~ Expression ~ ")")}

Primary = {(ThisExpression | PrimaryUnconditionalAssignableSelector | PrimaryArgumentPart | FunctionExpression | Literal | Identifier | NewExpression | ConstObjectExpression | ConstructorInvocation | PrimaryExpression)}

Literal = {(NullLiteral | BooleanLiteral | NumericLiteral | StringLiteral | SymbolLiteral | ListLiteral | SetOrMapLiteral)}

NullLiteral = {"null"}

NumericLiteral = {(NUMBER | HEX_NUMBER)}

BooleanLiteral = {("true" | "false")}

StringLiteralItem = {(MultilineString | SingleLineString)}

StringLiteral = {(StringLiteralItem)+}

ExpressionSingleLineStringSqMidMid = {(SINGLE_LINE_STRING_SQ_MID_MID ~ Expression)}

SingleLineStringSingleLineStringSqBeginMid = {(SINGLE_LINE_STRING_SQ_BEGIN_MID ~ Expression ~ (ExpressionSingleLineStringSqMidMid)* ~ SINGLE_LINE_STRING_SQ_MID_END)}

ExpressionSingleLineStringDqMidMid = {(SINGLE_LINE_STRING_DQ_MID_MID ~ Expression)}

SingleLineStringSingleLineStringDqBeginMid = {(SINGLE_LINE_STRING_DQ_BEGIN_MID ~ Expression ~ (ExpressionSingleLineStringDqMidMid)* ~ SINGLE_LINE_STRING_DQ_MID_END)}

SingleLineString = {(RAW_SINGLE_LINE_STRING | SINGLE_LINE_STRING_SQ_BEGIN_END | SingleLineStringSingleLineStringSqBeginMid | SINGLE_LINE_STRING_DQ_BEGIN_END | SingleLineStringSingleLineStringDqBeginMid)}

ExpressionMultiLineStringSqMidMid = {(MULTI_LINE_STRING_SQ_MID_MID ~ Expression)}

MultilineStringMultiLineStringSqBeginMid = {(MULTI_LINE_STRING_SQ_BEGIN_MID ~ Expression ~ (ExpressionMultiLineStringSqMidMid)* ~ MULTI_LINE_STRING_SQ_MID_END)}

ExpressionMultiLineStringDqMidMid = {(MULTI_LINE_STRING_DQ_MID_MID ~ Expression)}

MultilineStringMultiLineStringDqBeginMid = {(MULTI_LINE_STRING_DQ_BEGIN_MID ~ Expression ~ (ExpressionMultiLineStringDqMidMid)* ~ MULTI_LINE_STRING_DQ_MID_END)}

MultilineString = {(RAW_MULTI_LINE_STRING | MULTI_LINE_STRING_SQ_BEGIN_END | MultilineStringMultiLineStringSqBeginMid | MULTI_LINE_STRING_DQ_BEGIN_END | MultilineStringMultiLineStringDqBeginMid)}

StringInterpolationExpression = {("${" ~ Expression ~ "}")}

StringInterpolation = {(SIMPLE_STRING_INTERPOLATION | StringInterpolationExpression)}

SymbolLiteralOtherIdentifiers = {("." ~ Identifier)}

SymbolLiteralValueIdentifier = {(Identifier ~ (SymbolLiteralOtherIdentifiers)*)}

SymbolLiteralValue = {(SymbolLiteralValueIdentifier | Operator | "void")}

SymbolLiteral = {("#" ~ SymbolLiteralValue)}

ListLiteral = {(("const")? ~ (TypeArguments)? ~ "[" ~ (Elements)? ~ "]")}

SetOrMapLiteral = {(("const")? ~ (TypeArguments)? ~ "{" ~ (Elements)? ~ "}")}

ElementItem = {("," ~ Element)}

Elements = {(Element ~ (ElementItem)* ~ (",")?)}

Element = {(ExpressionElement | MapElement | SpreadElement | IfElement | ForElement)}

ExpressionElement = {Expression}

MapElement = {(Expression ~ ":" ~ Expression)}

SpreadElementType = {("..." | "...?")}

SpreadElement = {(SpreadElementType ~ Expression)}

ElementElse = {("else" ~ Element)}

IfElement = {("if" ~ "(" ~ Expression ~ ")" ~ Element ~ (ElementElse)?)}

ForElement = {(("await")? ~ "for" ~ "(" ~ ForLoopParts ~ ")" ~ Element)}

ThrowExpression = {("throw" ~ Expression)}

ThrowExpressionWithoutCascade = {("throw" ~ ExpressionWithoutCascade)}

FunctionExpression = {(FormalParameterPart ~ FunctionExpressionBody)}

FunctionExpressionBodyArrowToken = {(("async")? ~ "=>" ~ Expression)}

FunctionExpressionGeneratorAsyncToken = {("async" ~ ("*")?)}

FunctionExpressionGeneratorSyncToken = {("sync" ~ "*")}

FunctionExpressionGenerator = {(FunctionExpressionGeneratorAsyncToken | FunctionExpressionGeneratorSyncToken)}

FunctionExpressionBodyBlock = {((FunctionExpressionGenerator)? ~ Block)}

FunctionExpressionBody = {(FunctionExpressionBodyArrowToken | FunctionExpressionBodyBlock)}

ThisExpression = {"this"}

NewExpression = {("new" ~ ConstructorDesignation ~ Arguments)}

ConstObjectExpression = {("const" ~ ConstructorDesignation ~ Arguments)}

ArgumentsArgumentList = {(ArgumentList ~ (",")?)}

Arguments = {("(" ~ (ArgumentsArgumentList)? ~ ")")}

NamedArgumentItem = {("," ~ NamedArgument)}

ArgumentListNamedArgument = {(NamedArgument ~ (NamedArgumentItem)*)}

ArgumentListExpressionList = {(ExpressionList ~ (("," ~ NamedArgument))*)}

ArgumentList = {(ArgumentListNamedArgument | ArgumentListExpressionList)}

NamedArgument = {(Label ~ Expression)}

CascadeRight = {(".." ~ CascadeSection ~ (CascadeRight)?)}

CascadePrefixType = {("?.." | "..")}

CascadeLeft = {(ConditionalExpression ~ CascadePrefixType ~ CascadeSection)}

Cascade = {(CascadeLeft ~ (CascadeRight)?)}

CascadeSection = {(CascadeSelector ~ CascadeSectionTail)}

CascadeSelectorExpression = {("[" ~ Expression ~ "]")}

CascadeSelector = {(CascadeSelectorExpression | Identifier)}

SelectedCascadeAssignment = {(AssignableSelector ~ CascadeAssignment)}

SelectedCascade = {((Selector)* ~ (SelectedCascadeAssignment)?)}

CascadeSectionTail = {(CascadeAssignment | SelectedCascade)}

CascadeAssignment = {(AssignmentOperator ~ ExpressionWithoutCascade)}

AssignmentOperator = {("=" | CompoundAssignmentOperator)}

CompoundAssignmentOperator = {("*=" | "/=" | "~/=" | "%=" | "+=" | "-=" | "<<=" | ">>>=" | ">>=" | "&=" | "^=" | "|=" | "??=")}

ConditionalExpressionExpressionWithoutCascade = {("?" ~ ExpressionWithoutCascade ~ ":" ~ ExpressionWithoutCascade)}

ConditionalExpression = {(IfNullExpression ~ (ConditionalExpressionExpressionWithoutCascade)?)}

LogicalOrExpressionQuestionQuestion = {("??" ~ LogicalOrExpression)}

IfNullExpression = {(LogicalOrExpression ~ (LogicalOrExpressionQuestionQuestion)*)}

LogicalAndExpressionOr = {("||" ~ LogicalAndExpression)}

LogicalOrExpression = {(LogicalAndExpression ~ (LogicalAndExpressionOr)*)}

EqualityExpressionAnd = {("&&" ~ EqualityExpression)}

LogicalAndExpression = {(EqualityExpression ~ (EqualityExpressionAnd)*)}

EqualityExpressionInner = {(EqualityOperator ~ RelationalExpression)}

EqualityExpressionRelationalExpression = {(RelationalExpression ~ (EqualityExpressionInner)?)}

EqualityExpressionEqualityOperator = {("super" ~ EqualityOperator ~ RelationalExpression)}

EqualityExpression = {(EqualityExpressionRelationalExpression | EqualityExpressionEqualityOperator)}

EqualityOperator = {("==" | "!=")}

BitwiseOrExpressionInterRelationalOperator = {(RelationalOperator ~ BitwiseOrExpression)}

BitwiseOrExpressionInter = {(TypeTest | TypeCast | BitwiseOrExpressionInterRelationalOperator)}

RelationalExpressionBitwiseOrExpression = {(BitwiseOrExpression ~ (BitwiseOrExpressionInter)?)}

RelationalExpressionRelationalOperator = {("super" ~ RelationalOperator ~ BitwiseOrExpression)}

RelationalExpression = {(RelationalExpressionBitwiseOrExpression | RelationalExpressionRelationalOperator)}

RelationalOperator = {(">=" | ">" | "<=" | "<")}

BitwiseXorExpressionBitXor = {("|" ~ BitwiseXorExpression)}

BitwiseOrExpressionBitwiseXorExpression = {(BitwiseXorExpression ~ (BitwiseXorExpressionBitXor)*)}

BitwiseOrExpressionSuperToken = {("super" ~ (("|" ~ BitwiseXorExpression))+)}

BitwiseOrExpression = {(BitwiseOrExpressionBitwiseXorExpression | BitwiseOrExpressionSuperToken)}

BitwiseAndExpressionBitNeg = {("^" ~ BitwiseAndExpression)}

BitwiseXorExpressionBitwiseAndExpression = {(BitwiseAndExpression ~ (BitwiseAndExpressionBitNeg)*)}

BitwiseXorExpressionSuperToken = {("super" ~ (("^" ~ BitwiseAndExpression))+)}

BitwiseXorExpression = {(BitwiseXorExpressionBitwiseAndExpression | BitwiseXorExpressionSuperToken)}

ShiftExpressionBitAnd = {("&" ~ ShiftExpression)}

BitwiseAndExpressionShiftExpression = {(ShiftExpression ~ (ShiftExpressionBitAnd)*)}

BitwiseAndExpressionSuperToken = {("super" ~ (("&" ~ ShiftExpression))+)}

BitwiseAndExpression = {(BitwiseAndExpressionShiftExpression | BitwiseAndExpressionSuperToken)}

BitwiseOperator = {("&" | "^" | "|")}

ShiftExpressionInner = {(ShiftOperator ~ AdditiveExpression)}

ShiftExpressionAdditiveExpression = {(AdditiveExpression ~ (ShiftExpressionInner)*)}

ShiftExpressionSuperToken = {("super" ~ ((ShiftOperator ~ AdditiveExpression))+)}

ShiftExpression = {(ShiftExpressionAdditiveExpression | ShiftExpressionSuperToken)}

ShiftOperator = {("<<" | ">>>" | ">>")}

AdditiveExpressionInner = {(AdditiveOperator ~ MultiplicativeExpression)}

AdditiveExpressionMultiplicativeExpression = {(MultiplicativeExpression ~ (AdditiveExpressionInner)*)}

AdditiveExpressionSuperToken = {("super" ~ ((AdditiveOperator ~ MultiplicativeExpression))+)}

AdditiveExpression = {(AdditiveExpressionMultiplicativeExpression | AdditiveExpressionSuperToken)}

AdditiveOperator = {("+" | "-")}

MultiplicativeExpressionInner = {(MultiplicativeOperator ~ UnaryExpression)}

MultiplicativeExpressionUnaryExpression = {(UnaryExpression ~ (MultiplicativeExpressionInner)*)}

MultiplicativeExpressionSuperToken = {("super" ~ ((MultiplicativeOperator ~ UnaryExpression))+)}

MultiplicativeExpression = {(MultiplicativeExpressionUnaryExpression | MultiplicativeExpressionSuperToken)}

MultiplicativeOperator = {("*" | "/" | "%" | "~/")}

UnaryExpressionPrefixOperator = {(PrefixOperator ~ UnaryExpression)}

UnaryOperator = {(MinusOperator | TildeOperator)}

UnaryExpressionSuperToken = {(UnaryOperator ~ "super")}

UnaryExpressionIncrementOperator = {(IncrementOperator ~ AssignableExpression)}

UnaryExpression = {(UnaryExpressionPrefixOperator | AwaitExpression | PostfixExpression | UnaryExpressionSuperToken | UnaryExpressionIncrementOperator)}

PrefixOperator = {(MinusOperator | NegationOperator | TildeOperator)}

MinusOperator = {"-"}

NegationOperator = {"!"}

TildeOperator = {"~"}

AwaitExpression = {("await" ~ UnaryExpression)}

PostfixExpressionAssignableExpression = {(AssignableExpression ~ PostfixOperator)}

PostfixExpressionPrimary = {(Primary ~ (Selector)*)}

PostfixExpression = {(PostfixExpressionAssignableExpression | PostfixExpressionPrimary)}

PostfixOperator = {IncrementOperator}

ConstructorInvocation = {(TypeName ~ TypeArguments ~ "." ~ Identifier ~ Arguments)}

Selector = {("!" | AssignableSelector | ArgumentPart)}

ArgumentPart = {((TypeArguments)? ~ Arguments)}

IncrementOperator = {("++" | "--")}

AssignableExpressionPrimary = {(Primary ~ AssignableSelectorPart)}

AssignableExpressionUnconditionalAssignableSelector = {("super" ~ UnconditionalAssignableSelector)}

AssignableExpression = {(AssignableExpressionPrimary | AssignableExpressionUnconditionalAssignableSelector | Identifier)}

AssignableSelectorPart = {((Selector)* ~ AssignableSelector)}

UnconditionalAssignableSelectorExpression = {("[" ~ Expression ~ "]")}

UnconditionalAssignableSelectorIdentifier = {("." ~ Identifier)}

UnconditionalAssignableSelector = {(UnconditionalAssignableSelectorExpression | UnconditionalAssignableSelectorIdentifier)}

AssignableSelectorIdentifier = {("?." ~ Identifier)}

AssignableSelectorQuestionToken = {("?" ~ "[" ~ Expression ~ "]")}

AssignableSelector = {(UnconditionalAssignableSelector | AssignableSelectorIdentifier | AssignableSelectorQuestionToken)}

Identifier = {(IDENTIFIER | BUILT_IN_IDENTIFIER | OTHER_IDENTIFIER)}

TypeIdentifier = {(IDENTIFIER | OTHER_IDENTIFIER | "dynamic")}

QualifiedNameSingle = {(TypeIdentifier ~ "." ~ Identifier)}

QualifiedNameDouble = {(TypeIdentifier ~ "." ~ TypeIdentifier ~ "." ~ Identifier)}

QualifiedName = {(QualifiedNameSingle | QualifiedNameDouble)}

TypeTest = {(IsOperator ~ TypeNotVoid)}

IsOperator = {("is" ~ ("!")?)}

TypeCast = {(AsOperator ~ TypeNotVoid)}

AsOperator = {"as"}

Statements = {(Statement)*}

Statement = {((Label)* ~ NonLabelledStatement)}

NonLabelledStatement = {(Block | LocalVariableDeclaration | ForStatement | WhileStatement | DoStatement | SwitchStatement | IfStatement | RethrowStatement | TryStatement | BreakStatement | ContinueStatement | ReturnStatement | YieldStatement | YieldEachStatement | ExpressionStatement | AssertStatement | LocalFunctionDeclaration)}

ExpressionStatement = {((Expression)? ~ ";")}

LocalVariableDeclaration = {(Metadata ~ InitializedVariableDeclaration ~ ";")}

LocalFunctionDeclaration = {(Metadata ~ FunctionSignature ~ FunctionBody)}

StatementElse = {("else" ~ Statement)}

IfStatement = {("if" ~ "(" ~ Expression ~ ")" ~ Statement ~ (StatementElse)?)}

ForStatement = {(("await")? ~ "for" ~ "(" ~ ForLoopParts ~ ")" ~ Statement)}

ForLoopPartsSemicolonToken = {(ForInitializerStatement ~ (Expression)? ~ ";" ~ (ExpressionList)?)}

ForLoopPartsMetadata = {(Metadata ~ DeclaredIdentifier ~ "in" ~ Expression)}

ForLoopPartsInToken = {(Identifier ~ "in" ~ Expression)}

ForLoopParts = {(ForLoopPartsSemicolonToken | ForLoopPartsMetadata | ForLoopPartsInToken)}

ForInitializerStatementSemicolonToken = {((Expression)? ~ ";")}

ForInitializerStatement = {(LocalVariableDeclaration | ForInitializerStatementSemicolonToken)}

WhileStatement = {("while" ~ "(" ~ Expression ~ ")" ~ Statement)}

DoStatement = {("do" ~ Statement ~ "while" ~ "(" ~ Expression ~ ")" ~ ";")}

SwitchStatement = {("switch" ~ "(" ~ Expression ~ ")" ~ "{" ~ (SwitchCase)* ~ (DefaultCase)? ~ "}")}

SwitchCase = {((Label)* ~ "case" ~ Expression ~ ":" ~ Statements)}

DefaultCase = {((Label)* ~ "default" ~ ":" ~ Statements)}

RethrowStatement = {("rethrow" ~ ";")}

TryStatementOnPart = {((OnPart)+ ~ (FinallyPart)?)}

TryStatementCatchFinally = {(TryStatementOnPart | FinallyPart)}

TryStatement = {("try" ~ Block ~ TryStatementCatchFinally)}

OnPartCatchPart = {(CatchPart ~ Block)}

OnPartTypeNotVoid = {("on" ~ TypeNotVoid ~ (CatchPart)? ~ Block)}

OnPart = {(OnPartCatchPart | OnPartTypeNotVoid)}

IdentifierItem = {("," ~ Identifier)}

CatchPart = {("catch" ~ "(" ~ Identifier ~ (IdentifierItem)? ~ ")")}

FinallyPart = {("finally" ~ Block)}

ReturnStatement = {("return" ~ (Expression)? ~ ";")}

Label = {(Identifier ~ ":")}

BreakStatement = {("break" ~ (Identifier)? ~ ";")}

ContinueStatement = {("continue" ~ (Identifier)? ~ ";")}

YieldStatement = {("yield" ~ Expression ~ ";")}

YieldEachStatement = {("yield" ~ "*" ~ Expression ~ ";")}

AssertStatement = {(Assertion ~ ";")}

Assertion = {("assert" ~ "(" ~ Expression ~ (("," ~ Expression))? ~ (",")? ~ ")")}

ExternalFunctionSignature = {("external" ~ FunctionSignature ~ ";")}

ExternalGetterSignature = {("external" ~ GetterSignature ~ ";")}

ExternalSetterSignature = {("external" ~ SetterSignature ~ ";")}

TopLevelDeclarationFunctionSignature = {(FunctionSignature ~ FunctionBody)}

TopLevelDeclarationGetterSignature = {(GetterSignature ~ FunctionBody)}

TopLevelDeclarationSetterSignature = {(SetterSignature ~ FunctionBody)}

FinalOrConst = {("final" | "const")}

TopLevelDeclarationSemicolonToken = {(FinalOrConst ~ (Type)? ~ StaticFinalDeclarationList ~ ";")}

TopLevelDeclarationLateToken = {("late" ~ "final" ~ (Type)? ~ InitializedIdentifierList ~ ";")}

TopLevelDeclarationVarOrType = {(("late")? ~ VarOrType ~ InitializedIdentifierList ~ ";")}

TopLevelDeclaration = {(ClassDeclaration | MixinDeclaration | ExtensionDeclaration | EnumType | TypeAlias | ExternalFunctionSignature | ExternalGetterSignature | ExternalSetterSignature | TopLevelDeclarationFunctionSignature | TopLevelDeclarationGetterSignature | TopLevelDeclarationSetterSignature | TopLevelDeclarationSemicolonToken | TopLevelDeclarationLateToken | TopLevelDeclarationVarOrType)}

LibraryDeclarationMetadata = {(Metadata ~ TopLevelDeclaration)}

LibraryDeclaration = {((ScriptTag)? ~ (LibraryName)? ~ (ImportOrExport)* ~ (PartDirective)* ~ (LibraryDeclarationMetadata)* ~ EOI)}

ScriptTag = {("#!" ~ ((!(NEWLINE) ~ ANY))* ~ NEWLINE)}

LibraryName = {(Metadata ~ "library" ~ DottedIdentifierList ~ ";")}

ImportOrExport = {(LibraryImport | LibraryExport)}

DottedIdentifierList = {(Identifier ~ (("." ~ Identifier))*)}

LibraryImport = {(Metadata ~ ImportSpecification)}

ImportSpecificationAsToken = {(("deferred")? ~ "as" ~ Identifier)}

ImportSpecification = {("import" ~ ConfigurableUri ~ (ImportSpecificationAsToken)? ~ (Combinator)* ~ ";")}

LibraryExport = {(Metadata ~ "export" ~ ConfigurableUri ~ (Combinator)* ~ ";")}

ShowCombinator = {("show" ~ IdentifierList)}

HideCombinator = {("hide" ~ IdentifierList)}

Combinator = {(ShowCombinator | HideCombinator)}

IdentifierList = {(Identifier ~ (("," ~ Identifier))*)}

PartDirective = {(Metadata ~ "part" ~ Uri ~ ";")}

DottedIdentifierListOrUri = {(DottedIdentifierList | Uri)}

PartHeader = {(Metadata ~ "part" ~ "of" ~ DottedIdentifierListOrUri ~ ";")}

PartDeclarationMetadata = {(Metadata ~ TopLevelDeclaration)}

PartDeclaration = {(PartHeader ~ (PartDeclarationMetadata)* ~ EOI)}

Uri = {StringLiteral}

ConfigurableUri = {(Uri ~ (ConfigurationUri)*)}

ConfigurationUri = {("if" ~ "(" ~ UriTest ~ ")" ~ Uri)}

StringLiteralDoubleEqual = {("==" ~ StringLiteral)}

UriTest = {(DottedIdentifierList ~ (StringLiteralDoubleEqual)?)}

TypeFunctionType = {(FunctionType ~ ("?")?)}

Type = {(TypeFunctionType | TypeNotFunction)}

TypeNotVoidFunctionType = {(FunctionType ~ ("?")?)}

TypeNotVoid = {(TypeNotVoidFunctionType | TypeNotVoidNotFunction)}

TypeNotFunction = {("void" | TypeNotVoidNotFunction)}

TypeNotVoidNotFunctionTypeName = {(TypeName ~ (TypeArguments)? ~ ("?")?)}

TypeNotVoidNotFunctionFunctionToken = {("Function" ~ ("?")?)}

TypeNotVoidNotFunction = {(TypeNotVoidNotFunctionTypeName | TypeNotVoidNotFunctionFunctionToken)}

TypeIdentifierSelector = {("." ~ TypeIdentifier)}

TypeName = {(TypeIdentifier ~ (TypeIdentifierSelector)?)}

TypeArguments = {("<" ~ TypeList ~ ">")}

TypeItem = {("," ~ Type)}

TypeList = {(Type ~ (TypeItem)*)}

TypeNotVoidNotFunctionItem = {("," ~ TypeNotVoidNotFunction)}

TypeNotVoidNotFunctionList = {(TypeNotVoidNotFunction ~ (TypeNotVoidNotFunctionItem)*)}

FunctionTypeTypeNotFunction = {(TypeNotFunction ~ FunctionTypeTails)}

FunctionType = {(FunctionTypeTails | FunctionTypeTypeNotFunction)}

FunctionTypeTailsMany = {(FunctionTypeTail ~ ("?")? ~ FunctionTypeTails)}

FunctionTypeTails = {(FunctionTypeTailsMany | FunctionTypeTail)}

FunctionTypeTail = {("Function" ~ (TypeParameters)? ~ ParameterTypeList)}

NormalWithOptionalParameters = {("(" ~ NormalParameterTypes ~ "," ~ OptionalParameterTypes ~ ")")}

ParameterTypeListNormalParameterTypes = {("(" ~ NormalParameterTypes ~ (",")? ~ ")")}

ParameterTypeListOptionalParameterTypes = {("(" ~ OptionalParameterTypes ~ ")")}

ParameterTypeList = {(("(" ~ ")") | NormalWithOptionalParameters | ParameterTypeListNormalParameterTypes | ParameterTypeListOptionalParameterTypes)}

NormalParameterTypeItem = {("," ~ NormalParameterType)}

NormalParameterTypes = {(NormalParameterType ~ (NormalParameterTypeItem)*)}

IdentifierParameterType = {(Metadata ~ TypedIdentifier)}

TypeParameterType = {(Metadata ~ Type)}

NormalParameterType = {(IdentifierParameterType | TypeParameterType)}

OptionalParameterTypes = {(OptionalPositionalParameterTypes | NamedParameterTypes)}

OptionalPositionalParameterTypes = {("[" ~ NormalParameterTypes ~ (",")? ~ "]")}

NamedParameterTypeItem = {("," ~ NamedParameterType)}

NamedParameterTypes = {("{" ~ NamedParameterType ~ (NamedParameterTypeItem)* ~ (",")? ~ "}")}

NamedParameterType = {(Metadata ~ ("required")? ~ TypedIdentifier)}

TypedIdentifier = {(Type ~ Identifier)}

TypeAliasTypeIdentifier = {("typedef" ~ TypeIdentifier ~ (TypeParameters)? ~ "=" ~ Type ~ ";")}

TypeAliasFunctionTypeAlias = {("typedef" ~ FunctionTypeAlias)}

TypeAlias = {(TypeAliasTypeIdentifier | TypeAliasFunctionTypeAlias)}

FunctionTypeAlias = {(FunctionPrefix ~ FormalParameterPart ~ ";")}

FunctionPrefix = {((Type)? ~ Identifier)}

Comment = {(SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT)}

NUMBER = @{(((DIGIT)+ ~ (("." ~ (DIGIT)+))? ~ (EXPONENT)?) | ("." ~ (DIGIT)+ ~ (EXPONENT)?))}

EXPONENT = @{(("e" | "E") ~ (("+" | "-"))? ~ (DIGIT)+)}

HEX_NUMBER = @{(("0x" ~ (HEX_DIGIT)+) | ("0X" ~ (HEX_DIGIT)+))}

HEX_DIGIT = @{('a'..'f' | 'A'..'F' | DIGIT)}

RAW_SINGLE_LINE_STRING = @{(("r" ~ "'" ~ ((!(("'" | "\r" | "\n")) ~ ANY))* ~ "'") | ("r" ~ "\"" ~ ((!(("\"" | "\r" | "\n")) ~ ANY))* ~ "\""))}

STRING_CONTENT_COMMON = @{((!(("\\" | "'" | "\"" | "$" | "\r" | "\n")) ~ ANY) | ESCAPE_SEQUENCE | ("\\" ~ (!(("n" | "r" | "b" | "t" | "v" | "x" | "u" | "\r" | "\n")) ~ ANY)) | SIMPLE_STRING_INTERPOLATION)}

STRING_CONTENT_SQ = @{(STRING_CONTENT_COMMON | "\"")}

SINGLE_LINE_STRING_SQ_BEGIN_END = @{("'" ~ (STRING_CONTENT_SQ)* ~ "'")}

SINGLE_LINE_STRING_SQ_BEGIN_MID = @{("'" ~ (STRING_CONTENT_SQ)* ~ "${")}

SINGLE_LINE_STRING_SQ_MID_MID = @{("}" ~ (STRING_CONTENT_SQ)* ~ "${")}

SINGLE_LINE_STRING_SQ_MID_END = @{("}" ~ (STRING_CONTENT_SQ)* ~ "'")}

STRING_CONTENT_DQ = @{(STRING_CONTENT_COMMON | "'")}

SINGLE_LINE_STRING_DQ_BEGIN_END = @{("\"" ~ (STRING_CONTENT_DQ)* ~ "\"")}

SINGLE_LINE_STRING_DQ_BEGIN_MID = @{("\"" ~ (STRING_CONTENT_DQ)* ~ "${")}

SINGLE_LINE_STRING_DQ_MID_MID = @{("}" ~ (STRING_CONTENT_DQ)* ~ "${")}

SINGLE_LINE_STRING_DQ_MID_END = @{("}" ~ (STRING_CONTENT_DQ)* ~ "\"")}

RAW_MULTI_LINE_STRING = @{(("r" ~ "'''" ~ ANY ~ "'''") | ("r" ~ "\"\"\"" ~ ANY ~ "\"\"\""))}

QUOTES_SQ = @{("'" | "''")}

STRING_CONTENT_TSQ = @{((QUOTES_SQ)? ~ (STRING_CONTENT_COMMON | "\"" | "\r" | "\n"))}

MULTI_LINE_STRING_SQ_BEGIN_END = @{("'''" ~ (STRING_CONTENT_TSQ)* ~ "'''")}

MULTI_LINE_STRING_SQ_BEGIN_MID = @{("'''" ~ (STRING_CONTENT_TSQ)* ~ (QUOTES_SQ)? ~ "${")}

MULTI_LINE_STRING_SQ_MID_MID = @{("}" ~ (STRING_CONTENT_TSQ)* ~ (QUOTES_SQ)? ~ "${")}

MULTI_LINE_STRING_SQ_MID_END = @{("}" ~ (STRING_CONTENT_TSQ)* ~ "'''")}

QUOTES_DQ = @{("\"" | "\"\"")}

STRING_CONTENT_TDQ = @{((QUOTES_DQ)? ~ (STRING_CONTENT_COMMON | "'" | "\r" | "\n"))}

MULTI_LINE_STRING_DQ_BEGIN_END = @{("\"\"\"" ~ (STRING_CONTENT_TDQ)* ~ "\"\"\"")}

MULTI_LINE_STRING_DQ_BEGIN_MID = @{("\"\"\"" ~ (STRING_CONTENT_TDQ)* ~ (QUOTES_DQ)? ~ "${")}

MULTI_LINE_STRING_DQ_MID_MID = @{("}" ~ (STRING_CONTENT_TDQ)* ~ (QUOTES_DQ)? ~ "${")}

MULTI_LINE_STRING_DQ_MID_END = @{("}" ~ (STRING_CONTENT_TDQ)* ~ "\"\"\"")}

ESCAPE_SEQUENCE = @{("\n" | "\r" | "\\f" | "\\b" | "\t" | "\\v" | ("\\x" ~ HEX_DIGIT ~ HEX_DIGIT) | ("\\u" ~ HEX_DIGIT ~ HEX_DIGIT ~ HEX_DIGIT ~ HEX_DIGIT) | ("\\u{" ~ HEX_DIGIT_SEQUENCE ~ "}"))}

HEX_DIGIT_SEQUENCE = @{(HEX_DIGIT ~ (HEX_DIGIT)? ~ (HEX_DIGIT)? ~ (HEX_DIGIT)? ~ (HEX_DIGIT)? ~ (HEX_DIGIT)?)}

NEWLINE = @{("\n" | "\r" | "\r\n")}

SIMPLE_STRING_INTERPOLATION = @{("$" ~ (IDENTIFIER_NO_DOLLAR | BUILT_IN_IDENTIFIER | "this"))}

BUILT_IN_IDENTIFIER = @{("abstract" | "as" | "covariant" | "deferred" | "dynamic" | "export" | "external" | "extension" | "factory" | "Function" | "get" | "implements" | "import" | "interface" | "late" | "library" | "mixin" | "operator" | "part" | "required" | "set" | "static" | "typedef")}

OTHER_IDENTIFIER = @{("async" | "hide" | "of" | "on" | "show" | "sync" | "await" | "yield")}

IDENTIFIER_NO_DOLLAR = @{(IDENTIFIER_START_NO_DOLLAR ~ (IDENTIFIER_PART_NO_DOLLAR)*)}

IDENTIFIER_START_NO_DOLLAR = @{(LETTER | "_")}

IDENTIFIER_PART_NO_DOLLAR = @{(IDENTIFIER_START_NO_DOLLAR | DIGIT)}

IDENTIFIER = @{!RESERVED_WORD ~ (IDENTIFIER_START ~ (IDENTIFIER_PART)*)}

IDENTIFIER_START = @{(IDENTIFIER_START_NO_DOLLAR | "$")}

IDENTIFIER_PART = @{(IDENTIFIER_START | DIGIT)}

LETTER = @{('a'..'z' | 'A'..'Z')}

DIGIT = @{'0'..'9'}

WHITESPACE = @{(("\t" | " " | NEWLINE))+}

RESERVED_WORD = @{("assert" | "break" | "case" | "catch" | "class" | "const" | "continue" | "default" | "do" | "else" | "enum" | "extends" | "false" | "final" | "finally" | "for" | "if" | "in" | "is" | "new" | "null" | "rethrow" | "return" | "super" | "switch" | "this" | "throw" | "true" | "try" | "var" | "void" | "while" | "with") ~ !IDENTIFIER}

SINGLE_LINE_COMMENT = @{("//" ~ ((!(NEWLINE) ~ ANY))* ~ (NEWLINE)?)}

MULTI_LINE_COMMENT = @{("/*" ~ ((MULTI_LINE_COMMENT | (!("*/") ~ ANY)))* ~ "*/")}

COMMENT = @{(SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT)}