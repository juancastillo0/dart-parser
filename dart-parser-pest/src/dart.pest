LetExpression = {(LET_TOKEN ~ StaticFinalDeclarationList ~ IN_TOKEN ~ Expression)}

FinalConstVarOrTypeFinalToken = {((LATE_TOKEN)? ~ FINAL_TOKEN ~ (Type)?)}

FinalConstVarOrTypeConstToken = {(CONST_TOKEN ~ (Type)?)}

FinalConstVarOrTypeVarOrType = {((LATE_TOKEN)? ~ VarOrType)}

FinalConstVarOrType = {(FinalConstVarOrTypeFinalToken | FinalConstVarOrTypeConstToken | FinalConstVarOrTypeVarOrType)}

VarOrType = {(VAR_TOKEN | Type)}

ExpressionEqual = {(EQUAL_TOKEN ~ Expression)}

InitializedIdentifierItem = {(COMMA_TOKEN ~ InitializedIdentifier)}

InitializedVariableDeclaration = {(DeclaredIdentifier ~ (ExpressionEqual)? ~ (InitializedIdentifierItem)*)}

InitializedIdentifier = {(Identifier ~ ((EQUAL_TOKEN ~ Expression))?)}

InitializedIdentifierList = {(InitializedIdentifier ~ ((COMMA_TOKEN ~ InitializedIdentifier))*)}

FunctionSignature = {((Type)? ~ Identifier ~ FormalParameterPart)}

FormalParameterPart = {((TypeParameters)? ~ FormalParameterList)}

FunctionBodyArrowToken = {((ASYNC_TOKEN)? ~ ARROW_TOKEN ~ Expression ~ SEMICOLON_TOKEN)}

FunctionBodyGeneratorAsyncToken = {(ASYNC_TOKEN ~ (ASTERISK_TOKEN)?)}

FunctionBodyGeneratorSyncToken = {(SYNC_TOKEN ~ ASTERISK_TOKEN)}

FunctionBodyGenerator = {(FunctionBodyGeneratorAsyncToken | FunctionBodyGeneratorSyncToken)}

FunctionBodyBlock = {((FunctionBodyGenerator)? ~ Block)}

FunctionBody = {(FunctionBodyArrowToken | FunctionBodyBlock)}

Block = {(OPEN_CURLY_BRACKET_TOKEN ~ Statements ~ CLOSE_CURLY_BRACKET_TOKEN)}

EmptyParameters = {(OPEN_PAREN_TOKEN ~ CLOSE_PAREN_TOKEN)}

FormalParameterListNormalFormalParameters = {(OPEN_PAREN_TOKEN ~ NormalFormalParameters ~ (COMMA_TOKEN)? ~ CLOSE_PAREN_TOKEN)}

NormalWithOptionalOrNamedParameters = {(OPEN_PAREN_TOKEN ~ NormalFormalParameters ~ COMMA_TOKEN ~ OptionalOrNamedFormalParameters ~ CLOSE_PAREN_TOKEN)}

FormalParameterListOptionalOrNamedFormalParameters = {(OPEN_PAREN_TOKEN ~ OptionalOrNamedFormalParameters ~ CLOSE_PAREN_TOKEN)}

FormalParameterList = {(EmptyParameters | FormalParameterListNormalFormalParameters | NormalWithOptionalOrNamedParameters | FormalParameterListOptionalOrNamedFormalParameters)}

NormalFormalParameterItem = {(COMMA_TOKEN ~ NormalFormalParameter)}

NormalFormalParameters = {(NormalFormalParameter ~ (NormalFormalParameterItem)*)}

OptionalOrNamedFormalParameters = {(OptionalPositionalFormalParameters | NamedFormalParameters)}

DefaultFormalParameterItem = {(COMMA_TOKEN ~ DefaultFormalParameter)}

OptionalPositionalFormalParameters = {(OPEN_SQUARE_BRACKET_TOKEN ~ DefaultFormalParameter ~ (DefaultFormalParameterItem)* ~ (COMMA_TOKEN)? ~ CLOSE_SQUARE_BRACKET_TOKEN)}

DefaultNamedParameterItem = {(COMMA_TOKEN ~ DefaultNamedParameter)}

NamedFormalParameters = {(OPEN_CURLY_BRACKET_TOKEN ~ DefaultNamedParameter ~ (DefaultNamedParameterItem)* ~ (COMMA_TOKEN)? ~ CLOSE_CURLY_BRACKET_TOKEN)}

NormalFormalParameter = {(Metadata ~ NormalFormalParameterNoMetadata)}

NormalFormalParameterNoMetadata = {(FunctionFormalParameter | FieldFormalParameter | SimpleFormalParameter)}

FunctionFormalParameter = {((COVARIANT_TOKEN)? ~ (Type)? ~ Identifier ~ FormalParameterPart ~ (QUESTION_TOKEN)?)}

SimpleFormalParameterIdentifier = {((COVARIANT_TOKEN)? ~ Identifier)}

SimpleFormalParameter = {(DeclaredIdentifier | SimpleFormalParameterIdentifier)}

DeclaredIdentifier = {((COVARIANT_TOKEN)? ~ FinalConstVarOrType ~ Identifier)}

FieldFormalParameterFormalParameterPart = {(FormalParameterPart ~ (QUESTION_TOKEN)?)}

FieldFormalParameter = {((FinalConstVarOrType)? ~ THIS_TOKEN ~ PERIOD_TOKEN ~ Identifier ~ (FieldFormalParameterFormalParameterPart)?)}

DefaultFormalParameter = {(NormalFormalParameter ~ ((EQUAL_TOKEN ~ Expression))?)}

EqualTokenOrColonToken = {(EQUAL_TOKEN | COLON_TOKEN)}

DefaultNamedParameterAssignment = {(EqualTokenOrColonToken ~ Expression)}

DefaultNamedParameter = {(Metadata ~ (REQUIRED_TOKEN)? ~ NormalFormalParameterNoMetadata ~ (DefaultNamedParameterAssignment)?)}

ClassDeclarationMembers = {(Metadata ~ ClassMemberDeclaration)}

ClassDeclarationClassToken = {((ABSTRACT_TOKEN)? ~ CLASS_TOKEN ~ TypeIdentifier ~ (TypeParameters)? ~ (Superclass)? ~ (Interfaces)? ~ OPEN_CURLY_BRACKET_TOKEN ~ (ClassDeclarationMembers)* ~ CLOSE_CURLY_BRACKET_TOKEN)}

ClassDeclarationMixin = {((ABSTRACT_TOKEN)? ~ CLASS_TOKEN ~ MixinApplicationClass)}

ClassDeclaration = {(ClassDeclarationClassToken | ClassDeclarationMixin)}

TypeNotVoidItem = {(COMMA_TOKEN ~ TypeNotVoid)}

TypeNotVoidList = {(TypeNotVoid ~ (TypeNotVoidItem)*)}

ClassMemberDeclarationSemicolonToken = {(Declaration ~ SEMICOLON_TOKEN)}

ClassMemberDeclarationMethodSignature = {(MethodSignature ~ FunctionBody)}

ClassMemberDeclaration = {(ClassMemberDeclarationSemicolonToken | ClassMemberDeclarationMethodSignature)}

MethodSignatureConstructorSignature = {(ConstructorSignature ~ (Initializers)?)}

MethodSignatureFunctionSignature = {((STATIC_TOKEN)? ~ FunctionSignature)}

MethodSignatureGetterSignature = {((STATIC_TOKEN)? ~ GetterSignature)}

MethodSignatureSetterSignature = {((STATIC_TOKEN)? ~ SetterSignature)}

MethodSignature = {(MethodSignatureConstructorSignature | FactoryConstructorSignature | MethodSignatureFunctionSignature | MethodSignatureGetterSignature | MethodSignatureSetterSignature | OperatorSignature)}

DeclarationFactoryConstructorSignature = {(EXTERNAL_TOKEN ~ FactoryConstructorSignature)}

ExternalConstantConstructorSignature = {(EXTERNAL_TOKEN ~ ConstantConstructorSignature)}

ExternalConstructorSignature = {(EXTERNAL_TOKEN ~ ConstructorSignature)}

ExternalMaybeStatic = {(EXTERNAL_TOKEN ~ (STATIC_TOKEN)?)}

DeclarationGetterSignature = {((ExternalMaybeStatic)? ~ GetterSignature)}

DeclarationSetterSignature = {(((EXTERNAL_TOKEN ~ (STATIC_TOKEN)?))? ~ SetterSignature)}

DeclarationFunctionSignature = {(((EXTERNAL_TOKEN ~ (STATIC_TOKEN)?))? ~ FunctionSignature)}

DeclarationOperatorSignature = {((EXTERNAL_TOKEN)? ~ OperatorSignature)}

StaticConst = {(STATIC_TOKEN ~ CONST_TOKEN ~ (Type)? ~ StaticFinalDeclarationList)}

StaticFinal = {(STATIC_TOKEN ~ FINAL_TOKEN ~ (Type)? ~ StaticFinalDeclarationList)}

StaticLateFinal = {(STATIC_TOKEN ~ LATE_TOKEN ~ FINAL_TOKEN ~ (Type)? ~ InitializedIdentifierList)}

StaticVarOrType = {(STATIC_TOKEN ~ (LATE_TOKEN)? ~ VarOrType ~ InitializedIdentifierList)}

CovariantLateFinal = {(COVARIANT_TOKEN ~ LATE_TOKEN ~ FINAL_TOKEN ~ (Type)? ~ IdentifierList)}

CovariantVarOrType = {(COVARIANT_TOKEN ~ (LATE_TOKEN)? ~ VarOrType ~ InitializedIdentifierList)}

DeclarationFinalToken = {((LATE_TOKEN)? ~ FINAL_TOKEN ~ (Type)? ~ InitializedIdentifierList)}

DeclarationVarOrType = {((LATE_TOKEN)? ~ VarOrType ~ InitializedIdentifierList)}

RedirectionOrInitializers = {(Redirection | Initializers)}

DeclarationConstantConstructorSignature = {(ConstantConstructorSignature ~ (RedirectionOrInitializers)?)}

DeclarationConstructorSignature = {(ConstructorSignature ~ ((Redirection | Initializers))?)}

Declaration = {(DeclarationFactoryConstructorSignature | ExternalConstantConstructorSignature | ExternalConstructorSignature | DeclarationGetterSignature | DeclarationSetterSignature | DeclarationFunctionSignature | DeclarationOperatorSignature | StaticConst | StaticFinal | StaticLateFinal | StaticVarOrType | CovariantLateFinal | CovariantVarOrType | DeclarationFinalToken | DeclarationVarOrType | RedirectingFactoryConstructorSignature | DeclarationConstantConstructorSignature | DeclarationConstructorSignature)}

StaticFinalDeclarationItem = {(COMMA_TOKEN ~ StaticFinalDeclaration)}

StaticFinalDeclarationList = {(StaticFinalDeclaration ~ (StaticFinalDeclarationItem)*)}

StaticFinalDeclaration = {(Identifier ~ EQUAL_TOKEN ~ Expression)}

OperatorSignature = {((Type)? ~ OPERATOR_TOKEN ~ Operator ~ FormalParameterList)}

Operator = {(TILDE_TOKEN | BinaryOperator | SQUARE_BRACKETS_TOKEN | QUARE_BRACKETS_EQ_TOKEN)}

BinaryOperator = {(MultiplicativeOperator | AdditiveOperator | ShiftOperator | RelationalOperator | DOUBLE_EQUAL_TOKEN | BitwiseOperator)}

GetterSignature = {((Type)? ~ GET_TOKEN ~ Identifier)}

SetterSignature = {((Type)? ~ SET_TOKEN ~ Identifier ~ FormalParameterList)}

ConstructorSignature = {(ConstructorName ~ FormalParameterList)}

IdentifierSelector = {(PERIOD_TOKEN ~ Identifier)}

ConstructorName = {(TypeIdentifier ~ (IdentifierSelector)?)}

Redirection = {(COLON_TOKEN ~ THIS_TOKEN ~ ((PERIOD_TOKEN ~ Identifier))? ~ Arguments)}

InitializerListEntryItem = {(COMMA_TOKEN ~ InitializerListEntry)}

Initializers = {(COLON_TOKEN ~ InitializerListEntry ~ (InitializerListEntryItem)*)}

InitializerListEntryArguments = {(SUPER_TOKEN ~ Arguments)}

InitializerListEntrySuperToken = {(SUPER_TOKEN ~ PERIOD_TOKEN ~ Identifier ~ Arguments)}

InitializerListEntry = {(InitializerListEntryArguments | InitializerListEntrySuperToken | FieldInitializer | Assertion)}

FieldInitializerThisToken = {(THIS_TOKEN ~ PERIOD_TOKEN)}

FieldInitializer = {((FieldInitializerThisToken)? ~ Identifier ~ EQUAL_TOKEN ~ InitializerExpression)}

InitializerExpression = {(ConditionalExpression | Cascade)}

FactoryConstructorSignature = {((CONST_TOKEN)? ~ FACTORY_TOKEN ~ ConstructorName ~ FormalParameterList)}

RedirectingFactoryConstructorSignature = {((CONST_TOKEN)? ~ FACTORY_TOKEN ~ ConstructorName ~ FormalParameterList ~ EQUAL_TOKEN ~ ConstructorDesignation)}

ConstructorDesignationTypeName = {(TypeName ~ TypeArguments ~ ((PERIOD_TOKEN ~ Identifier))?)}

ConstructorDesignation = {(TypeIdentifier | QualifiedName | ConstructorDesignationTypeName)}

ConstantConstructorSignature = {(CONST_TOKEN ~ ConstructorName ~ FormalParameterList)}

SuperclassTypeNotVoid = {(EXTENDS_TOKEN ~ TypeNotVoid ~ (Mixins)?)}

Superclass = {(SuperclassTypeNotVoid | Mixins)}

Mixins = {(WITH_TOKEN ~ TypeNotVoidList)}

Interfaces = {(IMPLEMENTS_TOKEN ~ TypeNotVoidList)}

MixinApplicationClass = {(Identifier ~ (TypeParameters)? ~ EQUAL_TOKEN ~ MixinApplication ~ SEMICOLON_TOKEN)}

MixinApplication = {(TypeNotVoid ~ Mixins ~ (Interfaces)?)}

TypeNotVoidListOn = {(ON_TOKEN ~ TypeNotVoidList)}

MixinDeclarationMetadata = {(Metadata ~ ClassMemberDeclaration)}

MixinDeclaration = {(MIXIN_TOKEN ~ TypeIdentifier ~ (TypeParameters)? ~ (TypeNotVoidListOn)? ~ (Interfaces)? ~ OPEN_CURLY_BRACKET_TOKEN ~ (MixinDeclarationMetadata)* ~ CLOSE_CURLY_BRACKET_TOKEN)}

ExtensionDeclarationMetadata = {(Metadata ~ ClassMemberDeclaration)}

ExtensionDeclaration = {(EXTENSION_TOKEN ~ (Identifier)? ~ (TypeParameters)? ~ ON_TOKEN ~ Type ~ OPEN_CURLY_BRACKET_TOKEN ~ (ExtensionDeclarationMetadata)* ~ CLOSE_CURLY_BRACKET_TOKEN)}

EnumEntryItem = {(COMMA_TOKEN ~ EnumEntry)}

EnumType = {(ENUM_TOKEN ~ Identifier ~ OPEN_CURLY_BRACKET_TOKEN ~ EnumEntry ~ (EnumEntryItem)* ~ (COMMA_TOKEN)? ~ CLOSE_CURLY_BRACKET_TOKEN)}

EnumEntry = {(Metadata ~ Identifier)}

TypeNotVoidExtends = {(EXTENDS_TOKEN ~ TypeNotVoid)}

TypeParameter = {(Metadata ~ Identifier ~ (TypeNotVoidExtends)?)}

TypeParameterItem = {(COMMA_TOKEN ~ TypeParameter)}

TypeParameters = {(LESS_TOKEN ~ TypeParameter ~ (TypeParameterItem)* ~ MORE_TOKEN)}

MetadataItem = {(AT_TOKEN ~ Metadatum)}

Metadata = {(MetadataItem)*}

MetadatumConstructorDesignation = {(ConstructorDesignation ~ Arguments)}

Metadatum = {(Identifier | QualifiedName | MetadatumConstructorDesignation)}

ExpressionAssignableExpression = {(AssignableExpression ~ AssignmentOperator ~ Expression)}

Expression = {(ExpressionAssignableExpression | ConditionalExpression | Cascade | ThrowExpression)}

ExpressionWithoutCascadeAssignableExpression = {(AssignableExpression ~ AssignmentOperator ~ ExpressionWithoutCascade)}

ExpressionWithoutCascade = {(ExpressionWithoutCascadeAssignableExpression | ConditionalExpression | ThrowExpressionWithoutCascade)}

ExpressionItem = {(COMMA_TOKEN ~ Expression)}

ExpressionList = {(Expression ~ (ExpressionItem)*)}

PrimaryUnconditionalAssignableSelector = {(SUPER_TOKEN ~ UnconditionalAssignableSelector)}

PrimaryArgumentPart = {(SUPER_TOKEN ~ ArgumentPart)}

PrimaryExpression = {(OPEN_PAREN_TOKEN ~ Expression ~ CLOSE_PAREN_TOKEN)}

Primary = {(ThisExpression | PrimaryUnconditionalAssignableSelector | PrimaryArgumentPart | FunctionExpression | Literal | Identifier | NewExpression | ConstObjectExpression | ConstructorInvocation | PrimaryExpression)}

Literal = {(NullLiteral | BooleanLiteral | NumericLiteral | StringLiteral | SymbolLiteral | ListLiteral | SetOrMapLiteral)}

NullLiteral = {NULL_TOKEN}

NumericLiteral = {(NUMBER | HEX_NUMBER)}

BooleanLiteral = {(TRUE_TOKEN | FALSE_TOKEN)}

StringLiteralItem = {(MultilineString | SingleLineString)}

StringLiteral = {(StringLiteralItem)+}

ExpressionSingleLineStringSqMidMid = {(SINGLE_LINE_STRING_SQ_MID_MID ~ Expression)}

SingleLineStringSingleLineStringSqBeginMid = {(SINGLE_LINE_STRING_SQ_BEGIN_MID ~ Expression ~ (ExpressionSingleLineStringSqMidMid)* ~ SINGLE_LINE_STRING_SQ_MID_END)}

ExpressionSingleLineStringDqMidMid = {(SINGLE_LINE_STRING_DQ_MID_MID ~ Expression)}

SingleLineStringSingleLineStringDqBeginMid = {(SINGLE_LINE_STRING_DQ_BEGIN_MID ~ Expression ~ (ExpressionSingleLineStringDqMidMid)* ~ SINGLE_LINE_STRING_DQ_MID_END)}

SingleLineString = {(RAW_SINGLE_LINE_STRING | SINGLE_LINE_STRING_SQ_BEGIN_END | SingleLineStringSingleLineStringSqBeginMid | SINGLE_LINE_STRING_DQ_BEGIN_END | SingleLineStringSingleLineStringDqBeginMid)}

ExpressionMultiLineStringSqMidMid = {(MULTI_LINE_STRING_SQ_MID_MID ~ Expression)}

MultilineStringMultiLineStringSqBeginMid = {(MULTI_LINE_STRING_SQ_BEGIN_MID ~ Expression ~ (ExpressionMultiLineStringSqMidMid)* ~ MULTI_LINE_STRING_SQ_MID_END)}

ExpressionMultiLineStringDqMidMid = {(MULTI_LINE_STRING_DQ_MID_MID ~ Expression)}

MultilineStringMultiLineStringDqBeginMid = {(MULTI_LINE_STRING_DQ_BEGIN_MID ~ Expression ~ (ExpressionMultiLineStringDqMidMid)* ~ MULTI_LINE_STRING_DQ_MID_END)}

MultilineString = {(RAW_MULTI_LINE_STRING | MULTI_LINE_STRING_SQ_BEGIN_END | MultilineStringMultiLineStringSqBeginMid | MULTI_LINE_STRING_DQ_BEGIN_END | MultilineStringMultiLineStringDqBeginMid)}

StringInterpolationExpression = {(INTERPOLATION_START_TOKEN ~ Expression ~ CLOSE_CURLY_BRACKET_TOKEN)}

StringInterpolation = {(SIMPLE_STRING_INTERPOLATION | StringInterpolationExpression)}

SymbolLiteralOtherIdentifiers = {(PERIOD_TOKEN ~ Identifier)}

SymbolLiteralValueIdentifier = {(Identifier ~ (SymbolLiteralOtherIdentifiers)*)}

SymbolLiteralValue = {(SymbolLiteralValueIdentifier | Operator | VOID_TOKEN)}

SymbolLiteral = {(HASH_TOKEN ~ SymbolLiteralValue)}

ListLiteral = {((CONST_TOKEN)? ~ (TypeArguments)? ~ OPEN_SQUARE_BRACKET_TOKEN ~ (Elements)? ~ CLOSE_SQUARE_BRACKET_TOKEN)}

SetOrMapLiteral = {((CONST_TOKEN)? ~ (TypeArguments)? ~ OPEN_CURLY_BRACKET_TOKEN ~ (Elements)? ~ CLOSE_CURLY_BRACKET_TOKEN)}

ElementItem = {(COMMA_TOKEN ~ Element)}

Elements = {(Element ~ (ElementItem)* ~ (COMMA_TOKEN)?)}

Element = {(ExpressionElement | MapElement | SpreadElement | IfElement | ForElement)}

ExpressionElement = {Expression}

MapElement = {(Expression ~ COLON_TOKEN ~ Expression)}

SpreadElementType = {(POINTS_EXPAND_TOKEN | POINTS_EXPAND_QUESTION_TOKEN)}

SpreadElement = {(SpreadElementType ~ Expression)}

ElementElse = {(ELSE_TOKEN ~ Element)}

IfElement = {(IF_TOKEN ~ OPEN_PAREN_TOKEN ~ Expression ~ CLOSE_PAREN_TOKEN ~ Element ~ (ElementElse)?)}

ForElement = {((AWAIT_TOKEN)? ~ FOR_TOKEN ~ OPEN_PAREN_TOKEN ~ ForLoopParts ~ CLOSE_PAREN_TOKEN ~ Element)}

ThrowExpression = {(THROW_TOKEN ~ Expression)}

ThrowExpressionWithoutCascade = {(THROW_TOKEN ~ ExpressionWithoutCascade)}

FunctionExpression = {(FormalParameterPart ~ FunctionExpressionBody)}

FunctionExpressionBodyArrowToken = {((ASYNC_TOKEN)? ~ ARROW_TOKEN ~ Expression)}

FunctionExpressionGeneratorAsyncToken = {(ASYNC_TOKEN ~ (ASTERISK_TOKEN)?)}

FunctionExpressionGeneratorSyncToken = {(SYNC_TOKEN ~ ASTERISK_TOKEN)}

FunctionExpressionGenerator = {(FunctionExpressionGeneratorAsyncToken | FunctionExpressionGeneratorSyncToken)}

FunctionExpressionBodyBlock = {((FunctionExpressionGenerator)? ~ Block)}

FunctionExpressionBody = {(FunctionExpressionBodyArrowToken | FunctionExpressionBodyBlock)}

ThisExpression = {THIS_TOKEN}

NewExpression = {(NEW_TOKEN ~ ConstructorDesignation ~ Arguments)}

ConstObjectExpression = {(CONST_TOKEN ~ ConstructorDesignation ~ Arguments)}

ArgumentsArgumentList = {(ArgumentList ~ (COMMA_TOKEN)?)}

Arguments = {(OPEN_PAREN_TOKEN ~ (ArgumentsArgumentList)? ~ CLOSE_PAREN_TOKEN)}

NamedArgumentItem = {(COMMA_TOKEN ~ NamedArgument)}

ArgumentListNamedArgument = {(NamedArgument ~ (NamedArgumentItem)*)}

ArgumentListExpressionList = {(ExpressionList ~ ((COMMA_TOKEN ~ NamedArgument))*)}

ArgumentList = {(ArgumentListNamedArgument | ArgumentListExpressionList)}

NamedArgument = {(Label ~ Expression)}

CascadeRight = {(POINTS_ID_TOKEN ~ CascadeSection ~ (CascadeRight)?)}

CascadePrefixType = {(POINTS_ID_QUESTION_TOKEN | POINTS_ID_TOKEN)}

CascadeLeft = {(ConditionalExpression ~ CascadePrefixType ~ CascadeSection)}

Cascade = {(CascadeLeft ~ (CascadeRight)?)}

CascadeSection = {(CascadeSelector ~ CascadeSectionTail)}

CascadeSelectorExpression = {(OPEN_SQUARE_BRACKET_TOKEN ~ Expression ~ CLOSE_SQUARE_BRACKET_TOKEN)}

CascadeSelector = {(CascadeSelectorExpression | Identifier)}

SelectedCascadeAssignment = {(AssignableSelector ~ CascadeAssignment)}

SelectedCascade = {((Selector)* ~ (SelectedCascadeAssignment)?)}

CascadeSectionTail = {(CascadeAssignment | SelectedCascade)}

CascadeAssignment = {(AssignmentOperator ~ ExpressionWithoutCascade)}

AssignmentOperator = {(EQUAL_TOKEN | CompoundAssignmentOperator)}

CompoundAssignmentOperator = {(TIMES_EQUAL_TOKEN | DIV_EQUAL_TOKEN | INTEGER_DIV_EQUAL_TOKEN | MODULE_EQUAL_TOKEN | PLUS_EQUAL_TOKEN | MINUS_EQUAL_TOKEN | BIT_LEFT_EQUAL_TOKEN | BIT_RIGHT0_EQUAL_TOKEN | BIT_RIGHT_EQUAL_TOKEN | BIT_AND_EUQAL_TOKEN | BIT_NEG_EQUAL_TOKEN | BIT_XOR_EQUAL_TOKEN | QUESTION_QUESTION_EQUAL_TOKEN)}

ConditionalExpressionExpressionWithoutCascade = {(QUESTION_TOKEN ~ ExpressionWithoutCascade ~ COLON_TOKEN ~ ExpressionWithoutCascade)}

ConditionalExpression = {(IfNullExpression ~ (ConditionalExpressionExpressionWithoutCascade)?)}

LogicalOrExpressionQuestionQuestion = {(QUESTION_QUESTION_TOKEN ~ LogicalOrExpression)}

IfNullExpression = {(LogicalOrExpression ~ (LogicalOrExpressionQuestionQuestion)*)}

LogicalAndExpressionOr = {(OR_TOKEN ~ LogicalAndExpression)}

LogicalOrExpression = {(LogicalAndExpression ~ (LogicalAndExpressionOr)*)}

EqualityExpressionAnd = {(AND_TOKEN ~ EqualityExpression)}

LogicalAndExpression = {(EqualityExpression ~ (EqualityExpressionAnd)*)}

EqualityExpressionInner = {(EqualityOperator ~ RelationalExpression)}

EqualityExpressionRelationalExpression = {(RelationalExpression ~ (EqualityExpressionInner)?)}

EqualityExpressionEqualityOperator = {(SUPER_TOKEN ~ EqualityOperator ~ RelationalExpression)}

EqualityExpression = {(EqualityExpressionRelationalExpression | EqualityExpressionEqualityOperator)}

EqualityOperator = {(DOUBLE_EQUAL_TOKEN | NOT_EQUAL_TOKEN)}

BitwiseOrExpressionInterRelationalOperator = {(RelationalOperator ~ BitwiseOrExpression)}

BitwiseOrExpressionInter = {(TypeTest | TypeCast | BitwiseOrExpressionInterRelationalOperator)}

RelationalExpressionBitwiseOrExpression = {(BitwiseOrExpression ~ (BitwiseOrExpressionInter)?)}

RelationalExpressionRelationalOperator = {(SUPER_TOKEN ~ RelationalOperator ~ BitwiseOrExpression)}

RelationalExpression = {(RelationalExpressionBitwiseOrExpression | RelationalExpressionRelationalOperator)}

RelationalOperator = {(MORE_OR_EQUAL_TOKEN | MORE_TOKEN | LESS_OR_EQUAL_TOKEN | LESS_TOKEN)}

BitwiseXorExpressionBitXor = {(BIT_XOR_TOKEN ~ BitwiseXorExpression)}

BitwiseOrExpressionBitwiseXorExpression = {(BitwiseXorExpression ~ (BitwiseXorExpressionBitXor)*)}

BitwiseOrExpressionSuperToken = {(SUPER_TOKEN ~ ((BIT_XOR_TOKEN ~ BitwiseXorExpression))+)}

BitwiseOrExpression = {(BitwiseOrExpressionBitwiseXorExpression | BitwiseOrExpressionSuperToken)}

BitwiseAndExpressionBitNeg = {(BIT_NEG_TOKEN ~ BitwiseAndExpression)}

BitwiseXorExpressionBitwiseAndExpression = {(BitwiseAndExpression ~ (BitwiseAndExpressionBitNeg)*)}

BitwiseXorExpressionSuperToken = {(SUPER_TOKEN ~ ((BIT_NEG_TOKEN ~ BitwiseAndExpression))+)}

BitwiseXorExpression = {(BitwiseXorExpressionBitwiseAndExpression | BitwiseXorExpressionSuperToken)}

ShiftExpressionBitAnd = {(BIT_AND_TOKEN ~ ShiftExpression)}

BitwiseAndExpressionShiftExpression = {(ShiftExpression ~ (ShiftExpressionBitAnd)*)}

BitwiseAndExpressionSuperToken = {(SUPER_TOKEN ~ ((BIT_AND_TOKEN ~ ShiftExpression))+)}

BitwiseAndExpression = {(BitwiseAndExpressionShiftExpression | BitwiseAndExpressionSuperToken)}

BitwiseOperator = {(BIT_AND_TOKEN | BIT_NEG_TOKEN | BIT_XOR_TOKEN)}

ShiftExpressionInner = {(ShiftOperator ~ AdditiveExpression)}

ShiftExpressionAdditiveExpression = {(AdditiveExpression ~ (ShiftExpressionInner)*)}

ShiftExpressionSuperToken = {(SUPER_TOKEN ~ ((ShiftOperator ~ AdditiveExpression))+)}

ShiftExpression = {(ShiftExpressionAdditiveExpression | ShiftExpressionSuperToken)}

ShiftOperator = {(BIT_LEFT_TOKEN | BIT_RIGHT0_TOKEN | BIT_RIGHT_TOKEN)}

AdditiveExpressionInner = {(AdditiveOperator ~ MultiplicativeExpression)}

AdditiveExpressionMultiplicativeExpression = {(MultiplicativeExpression ~ (AdditiveExpressionInner)*)}

AdditiveExpressionSuperToken = {(SUPER_TOKEN ~ ((AdditiveOperator ~ MultiplicativeExpression))+)}

AdditiveExpression = {(AdditiveExpressionMultiplicativeExpression | AdditiveExpressionSuperToken)}

AdditiveOperator = {(PLUS_TOKEN | MINUS_TOKEN)}

MultiplicativeExpressionInner = {(MultiplicativeOperator ~ UnaryExpression)}

MultiplicativeExpressionUnaryExpression = {(UnaryExpression ~ (MultiplicativeExpressionInner)*)}

MultiplicativeExpressionSuperToken = {(SUPER_TOKEN ~ ((MultiplicativeOperator ~ UnaryExpression))+)}

MultiplicativeExpression = {(MultiplicativeExpressionUnaryExpression | MultiplicativeExpressionSuperToken)}

MultiplicativeOperator = {(ASTERISK_TOKEN | DIVIDE_TOKEN | MODULUS_TOKEN | INTEGER_DIV_TOKEN)}

UnaryExpressionPrefixOperator = {(PrefixOperator ~ UnaryExpression)}

UnaryOperator = {(MinusOperator | TildeOperator)}

UnaryExpressionSuperToken = {(UnaryOperator ~ SUPER_TOKEN)}

UnaryExpressionIncrementOperator = {(IncrementOperator ~ AssignableExpression)}

UnaryExpression = {(UnaryExpressionPrefixOperator | AwaitExpression | PostfixExpression | UnaryExpressionSuperToken | UnaryExpressionIncrementOperator)}

PrefixOperator = {(MinusOperator | NegationOperator | TildeOperator)}

MinusOperator = {MINUS_TOKEN}

NegationOperator = {EXCLAMATION_TOKEN}

TildeOperator = {TILDE_TOKEN}

AwaitExpression = {(AWAIT_TOKEN ~ UnaryExpression)}

PostfixExpressionAssignableExpression = {(AssignableExpression ~ PostfixOperator)}

PostfixExpressionPrimary = {(Primary ~ (Selector)*)}

PostfixExpression = {(PostfixExpressionAssignableExpression | PostfixExpressionPrimary)}

PostfixOperator = {IncrementOperator}

ConstructorInvocation = {(TypeName ~ TypeArguments ~ PERIOD_TOKEN ~ Identifier ~ Arguments)}

Selector = {(EXCLAMATION_TOKEN | AssignableSelector | ArgumentPart)}

ArgumentPart = {((TypeArguments)? ~ Arguments)}

IncrementOperator = {(PLUS_PLUS_TOKEN | MINUS_MINUS_TOKEN)}

AssignableExpressionPrimary = {(Primary ~ AssignableSelectorPart)}

AssignableExpressionUnconditionalAssignableSelector = {(SUPER_TOKEN ~ UnconditionalAssignableSelector)}

AssignableExpression = {(AssignableExpressionPrimary | AssignableExpressionUnconditionalAssignableSelector | Identifier)}

AssignableSelectorPart = {((Selector)* ~ AssignableSelector)}

UnconditionalAssignableSelectorExpression = {(OPEN_SQUARE_BRACKET_TOKEN ~ Expression ~ CLOSE_SQUARE_BRACKET_TOKEN)}

UnconditionalAssignableSelectorIdentifier = {(PERIOD_TOKEN ~ Identifier)}

UnconditionalAssignableSelector = {(UnconditionalAssignableSelectorExpression | UnconditionalAssignableSelectorIdentifier)}

AssignableSelectorIdentifier = {(QUESTION_ID_TOKEN ~ Identifier)}

AssignableSelectorQuestionToken = {(QUESTION_TOKEN ~ OPEN_SQUARE_BRACKET_TOKEN ~ Expression ~ CLOSE_SQUARE_BRACKET_TOKEN)}

AssignableSelector = {(UnconditionalAssignableSelector | AssignableSelectorIdentifier | AssignableSelectorQuestionToken)}

Identifier = {(IDENTIFIER | BUILT_IN_IDENTIFIER | OTHER_IDENTIFIER)}

TypeIdentifier = {(IDENTIFIER | OTHER_IDENTIFIER | DYNAMIC_TOKEN)}

QualifiedNameSingle = {(TypeIdentifier ~ PERIOD_TOKEN ~ Identifier)}

QualifiedNameDouble = {(TypeIdentifier ~ PERIOD_TOKEN ~ TypeIdentifier ~ PERIOD_TOKEN ~ Identifier)}

QualifiedName = {(QualifiedNameSingle | QualifiedNameDouble)}

TypeTest = {(IsOperator ~ TypeNotVoid)}

IsOperator = {(IS_TOKEN ~ (EXCLAMATION_TOKEN)?)}

TypeCast = {(AsOperator ~ TypeNotVoid)}

AsOperator = {AS_TOKEN}

Statements = {(Statement)*}

Statement = {((Label)* ~ NonLabelledStatement)}

NonLabelledStatement = {(Block | LocalVariableDeclaration | ForStatement | WhileStatement | DoStatement | SwitchStatement | IfStatement | RethrowStatement | TryStatement | BreakStatement | ContinueStatement | ReturnStatement | YieldStatement | YieldEachStatement | ExpressionStatement | AssertStatement | LocalFunctionDeclaration)}

ExpressionStatement = {((Expression)? ~ SEMICOLON_TOKEN)}

LocalVariableDeclaration = {(Metadata ~ InitializedVariableDeclaration ~ SEMICOLON_TOKEN)}

LocalFunctionDeclaration = {(Metadata ~ FunctionSignature ~ FunctionBody)}

StatementElse = {(ELSE_TOKEN ~ Statement)}

IfStatement = {(IF_TOKEN ~ OPEN_PAREN_TOKEN ~ Expression ~ CLOSE_PAREN_TOKEN ~ Statement ~ (StatementElse)?)}

ForStatement = {((AWAIT_TOKEN)? ~ FOR_TOKEN ~ OPEN_PAREN_TOKEN ~ ForLoopParts ~ CLOSE_PAREN_TOKEN ~ Statement)}

ForLoopPartsSemicolonToken = {(ForInitializerStatement ~ (Expression)? ~ SEMICOLON_TOKEN ~ (ExpressionList)?)}

ForLoopPartsMetadata = {(Metadata ~ DeclaredIdentifier ~ IN_TOKEN ~ Expression)}

ForLoopPartsInToken = {(Identifier ~ IN_TOKEN ~ Expression)}

ForLoopParts = {(ForLoopPartsSemicolonToken | ForLoopPartsMetadata | ForLoopPartsInToken)}

ForInitializerStatementSemicolonToken = {((Expression)? ~ SEMICOLON_TOKEN)}

ForInitializerStatement = {(LocalVariableDeclaration | ForInitializerStatementSemicolonToken)}

WhileStatement = {(WHILE_TOKEN ~ OPEN_PAREN_TOKEN ~ Expression ~ CLOSE_PAREN_TOKEN ~ Statement)}

DoStatement = {(DO_TOKEN ~ Statement ~ WHILE_TOKEN ~ OPEN_PAREN_TOKEN ~ Expression ~ CLOSE_PAREN_TOKEN ~ SEMICOLON_TOKEN)}

SwitchStatement = {(SWITCH_TOKEN ~ OPEN_PAREN_TOKEN ~ Expression ~ CLOSE_PAREN_TOKEN ~ OPEN_CURLY_BRACKET_TOKEN ~ (SwitchCase)* ~ (DefaultCase)? ~ CLOSE_CURLY_BRACKET_TOKEN)}

SwitchCase = {((Label)* ~ CASE_TOKEN ~ Expression ~ COLON_TOKEN ~ Statements)}

DefaultCase = {((Label)* ~ DEFAULT_TOKEN ~ COLON_TOKEN ~ Statements)}

RethrowStatement = {(RETHROW_TOKEN ~ SEMICOLON_TOKEN)}

TryStatementOnPart = {((OnPart)+ ~ (FinallyPart)?)}

TryStatementCatchFinally = {(TryStatementOnPart | FinallyPart)}

TryStatement = {(TRY_TOKEN ~ Block ~ TryStatementCatchFinally)}

OnPartCatchPart = {(CatchPart ~ Block)}

OnPartTypeNotVoid = {(ON_TOKEN ~ TypeNotVoid ~ (CatchPart)? ~ Block)}

OnPart = {(OnPartCatchPart | OnPartTypeNotVoid)}

IdentifierItem = {(COMMA_TOKEN ~ Identifier)}

CatchPart = {(CATCH_TOKEN ~ OPEN_PAREN_TOKEN ~ Identifier ~ (IdentifierItem)? ~ CLOSE_PAREN_TOKEN)}

FinallyPart = {(FINALLY_TOKEN ~ Block)}

ReturnStatement = {(RETURN_TOKEN ~ (Expression)? ~ SEMICOLON_TOKEN)}

Label = {(Identifier ~ COLON_TOKEN)}

BreakStatement = {(BREAK_TOKEN ~ (Identifier)? ~ SEMICOLON_TOKEN)}

ContinueStatement = {(CONTINUE_TOKEN ~ (Identifier)? ~ SEMICOLON_TOKEN)}

YieldStatement = {(YIELD_TOKEN ~ Expression ~ SEMICOLON_TOKEN)}

YieldEachStatement = {(YIELD_TOKEN ~ ASTERISK_TOKEN ~ Expression ~ SEMICOLON_TOKEN)}

AssertStatement = {(Assertion ~ SEMICOLON_TOKEN)}

Assertion = {(ASSERT_TOKEN ~ OPEN_PAREN_TOKEN ~ Expression ~ ((COMMA_TOKEN ~ Expression))? ~ (COMMA_TOKEN)? ~ CLOSE_PAREN_TOKEN)}

ExternalFunctionSignature = {(EXTERNAL_TOKEN ~ FunctionSignature ~ SEMICOLON_TOKEN)}

ExternalGetterSignature = {(EXTERNAL_TOKEN ~ GetterSignature ~ SEMICOLON_TOKEN)}

ExternalSetterSignature = {(EXTERNAL_TOKEN ~ SetterSignature ~ SEMICOLON_TOKEN)}

TopLevelDeclarationFunctionSignature = {(FunctionSignature ~ FunctionBody)}

TopLevelDeclarationGetterSignature = {(GetterSignature ~ FunctionBody)}

TopLevelDeclarationSetterSignature = {(SetterSignature ~ FunctionBody)}

FinalOrConst = {(FINAL_TOKEN | CONST_TOKEN)}

TopLevelDeclarationSemicolonToken = {(FinalOrConst ~ (Type)? ~ StaticFinalDeclarationList ~ SEMICOLON_TOKEN)}

TopLevelDeclarationLateToken = {(LATE_TOKEN ~ FINAL_TOKEN ~ (Type)? ~ InitializedIdentifierList ~ SEMICOLON_TOKEN)}

TopLevelDeclarationVarOrType = {((LATE_TOKEN)? ~ VarOrType ~ InitializedIdentifierList ~ SEMICOLON_TOKEN)}

TopLevelDeclaration = {(ClassDeclaration | MixinDeclaration | ExtensionDeclaration | EnumType | TypeAlias | ExternalFunctionSignature | ExternalGetterSignature | ExternalSetterSignature | TopLevelDeclarationFunctionSignature | TopLevelDeclarationGetterSignature | TopLevelDeclarationSetterSignature | TopLevelDeclarationSemicolonToken | TopLevelDeclarationLateToken | TopLevelDeclarationVarOrType)}

LibraryDeclarationMetadata = {(Metadata ~ TopLevelDeclaration)}

LibraryDeclaration = {((ScriptTag)? ~ (LibraryName)? ~ (ImportOrExport)* ~ (PartDirective)* ~ (LibraryDeclarationMetadata)* ~ EOI)}

ScriptTag = {(HASH_EXCLAMATION_TOKEN ~ SCRIPT_TAG_CONTENT ~ NEWLINE)}

LibraryName = {(Metadata ~ LIBRARY_TOKEN ~ DottedIdentifierList ~ SEMICOLON_TOKEN)}

ImportOrExport = {(LibraryImport | LibraryExport)}

DottedIdentifierList = {(Identifier ~ ((PERIOD_TOKEN ~ Identifier))*)}

LibraryImport = {(Metadata ~ ImportSpecification)}

ImportSpecificationAsToken = {((DEFERRED_TOKEN)? ~ AS_TOKEN ~ Identifier)}

ImportSpecification = {(IMPORT_TOKEN ~ ConfigurableUri ~ (ImportSpecificationAsToken)? ~ (Combinator)* ~ SEMICOLON_TOKEN)}

LibraryExport = {(Metadata ~ EXPORT_TOKEN ~ ConfigurableUri ~ (Combinator)* ~ SEMICOLON_TOKEN)}

ShowCombinator = {(SHOW_TOKEN ~ IdentifierList)}

HideCombinator = {(HIDE_TOKEN ~ IdentifierList)}

Combinator = {(ShowCombinator | HideCombinator)}

IdentifierList = {(Identifier ~ ((COMMA_TOKEN ~ Identifier))*)}

PartDirective = {(Metadata ~ PART_TOKEN ~ Uri ~ SEMICOLON_TOKEN)}

DottedIdentifierListOrUri = {(DottedIdentifierList | Uri)}

PartHeader = {(Metadata ~ PART_TOKEN ~ OF_TOKEN ~ DottedIdentifierListOrUri ~ SEMICOLON_TOKEN)}

PartDeclarationMetadata = {(Metadata ~ TopLevelDeclaration)}

PartDeclaration = {(PartHeader ~ (PartDeclarationMetadata)* ~ EOI)}

Uri = {StringLiteral}

ConfigurableUri = {(Uri ~ (ConfigurationUri)*)}

ConfigurationUri = {(IF_TOKEN ~ OPEN_PAREN_TOKEN ~ UriTest ~ CLOSE_PAREN_TOKEN ~ Uri)}

StringLiteralDoubleEqual = {(DOUBLE_EQUAL_TOKEN ~ StringLiteral)}

UriTest = {(DottedIdentifierList ~ (StringLiteralDoubleEqual)?)}

TypeFunctionType = {(FunctionType ~ (QUESTION_TOKEN)?)}

Type = {(TypeFunctionType | TypeNotFunction)}

TypeNotVoidFunctionType = {(FunctionType ~ (QUESTION_TOKEN)?)}

TypeNotVoid = {(TypeNotVoidFunctionType | TypeNotVoidNotFunction)}

TypeNotFunction = {(VOID_TOKEN | TypeNotVoidNotFunction)}

TypeNotVoidNotFunctionTypeName = {(TypeName ~ (TypeArguments)? ~ (QUESTION_TOKEN)?)}

TypeNotVoidNotFunctionFunctionToken = {(FUNCTION_TOKEN ~ (QUESTION_TOKEN)?)}

TypeNotVoidNotFunction = {(TypeNotVoidNotFunctionTypeName | TypeNotVoidNotFunctionFunctionToken)}

TypeIdentifierSelector = {(PERIOD_TOKEN ~ TypeIdentifier)}

TypeName = {(TypeIdentifier ~ (TypeIdentifierSelector)?)}

TypeArguments = {(LESS_TOKEN ~ TypeList ~ MORE_TOKEN)}

TypeItem = {(COMMA_TOKEN ~ Type)}

TypeList = {(Type ~ (TypeItem)*)}

TypeNotVoidNotFunctionItem = {(COMMA_TOKEN ~ TypeNotVoidNotFunction)}

TypeNotVoidNotFunctionList = {(TypeNotVoidNotFunction ~ (TypeNotVoidNotFunctionItem)*)}

FunctionTypeTypeNotFunction = {(TypeNotFunction ~ FunctionTypeTails)}

FunctionType = {(FunctionTypeTails | FunctionTypeTypeNotFunction)}

FunctionTypeTailsMany = {(FunctionTypeTail ~ (QUESTION_TOKEN)? ~ FunctionTypeTails)}

FunctionTypeTails = {(FunctionTypeTailsMany | FunctionTypeTail)}

FunctionTypeTail = {(FUNCTION_TOKEN ~ (TypeParameters)? ~ ParameterTypeList)}

NormalWithOptionalParameters = {(OPEN_PAREN_TOKEN ~ NormalParameterTypes ~ COMMA_TOKEN ~ OptionalParameterTypes ~ CLOSE_PAREN_TOKEN)}

ParameterTypeListNormalParameterTypes = {(OPEN_PAREN_TOKEN ~ NormalParameterTypes ~ (COMMA_TOKEN)? ~ CLOSE_PAREN_TOKEN)}

ParameterTypeListOptionalParameterTypes = {(OPEN_PAREN_TOKEN ~ OptionalParameterTypes ~ CLOSE_PAREN_TOKEN)}

ParameterTypeList = {((OPEN_PAREN_TOKEN ~ CLOSE_PAREN_TOKEN) | NormalWithOptionalParameters | ParameterTypeListNormalParameterTypes | ParameterTypeListOptionalParameterTypes)}

NormalParameterTypeItem = {(COMMA_TOKEN ~ NormalParameterType)}

NormalParameterTypes = {(NormalParameterType ~ (NormalParameterTypeItem)*)}

IdentifierParameterType = {(Metadata ~ TypedIdentifier)}

TypeParameterType = {(Metadata ~ Type)}

NormalParameterType = {(IdentifierParameterType | TypeParameterType)}

OptionalParameterTypes = {(OptionalPositionalParameterTypes | NamedParameterTypes)}

OptionalPositionalParameterTypes = {(OPEN_SQUARE_BRACKET_TOKEN ~ NormalParameterTypes ~ (COMMA_TOKEN)? ~ CLOSE_SQUARE_BRACKET_TOKEN)}

NamedParameterTypeItem = {(COMMA_TOKEN ~ NamedParameterType)}

NamedParameterTypes = {(OPEN_CURLY_BRACKET_TOKEN ~ NamedParameterType ~ (NamedParameterTypeItem)* ~ (COMMA_TOKEN)? ~ CLOSE_CURLY_BRACKET_TOKEN)}

NamedParameterType = {(Metadata ~ (REQUIRED_TOKEN)? ~ TypedIdentifier)}

TypedIdentifier = {(Type ~ Identifier)}

TypeAliasTypeIdentifier = {(TYPEDEF_TOKEN ~ TypeIdentifier ~ (TypeParameters)? ~ EQUAL_TOKEN ~ Type ~ SEMICOLON_TOKEN)}

TypeAliasFunctionTypeAlias = {(TYPEDEF_TOKEN ~ FunctionTypeAlias)}

TypeAlias = {(TypeAliasTypeIdentifier | TypeAliasFunctionTypeAlias)}

FunctionTypeAlias = {(FunctionPrefix ~ FormalParameterPart ~ SEMICOLON_TOKEN)}

FunctionPrefix = {((Type)? ~ Identifier)}

Comment = {(SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT)}

NUMBER = @{(((DIGIT)+ ~ ((PERIOD_TOKEN ~ (DIGIT)+))? ~ (EXPONENT)?) | (PERIOD_TOKEN ~ (DIGIT)+ ~ (EXPONENT)?))}

EXPONENT = @{((EXPONENT_TOKEN | SCIENTIFIC_TOKEN) ~ ((PLUS_TOKEN | MINUS_TOKEN))? ~ (DIGIT)+)}

HEX_NUMBER = @{((HEX0X_TOKEN ~ (HEX_DIGIT)+) | (HEX0_X_TOKEN ~ (HEX_DIGIT)+))}

HEX_DIGIT = @{('a'..'f' | 'A'..'F' | DIGIT)}

RAW_SINGLE_LINE_STRING = @{((R_TOKEN ~ QUOTE_TOKEN ~ ((!((QUOTE_TOKEN | R_ESCAPE_TOKEN | NEWLINE_TOKEN)) ~ ANY))* ~ QUOTE_TOKEN) | (R_TOKEN ~ DOUBLE_QUOTE_TOKEN ~ ((!((DOUBLE_QUOTE_TOKEN | R_ESCAPE_TOKEN | NEWLINE_TOKEN)) ~ ANY))* ~ DOUBLE_QUOTE_TOKEN))}

STRING_CONTENT_COMMON = @{((!((BACK_TOKEN | QUOTE_TOKEN | DOUBLE_QUOTE_TOKEN | DOLLAR_TOKEN | R_ESCAPE_TOKEN | NEWLINE_TOKEN)) ~ ANY) | ESCAPE_SEQUENCE | (BACK_TOKEN ~ (!((N_TOKEN | R_TOKEN | B_TOKEN | T_TOKEN | V_TOKEN | X_TOKEN | U_TOKEN | R_ESCAPE_TOKEN | NEWLINE_TOKEN)) ~ ANY)) | SIMPLE_STRING_INTERPOLATION)}

STRING_CONTENT_SQ = @{(STRING_CONTENT_COMMON | DOUBLE_QUOTE_TOKEN)}

SINGLE_LINE_STRING_SQ_BEGIN_END = @{(QUOTE_TOKEN ~ (STRING_CONTENT_SQ)* ~ QUOTE_TOKEN)}

SINGLE_LINE_STRING_SQ_BEGIN_MID = @{(QUOTE_TOKEN ~ (STRING_CONTENT_SQ)* ~ INTERPOLATION_START_TOKEN)}

SINGLE_LINE_STRING_SQ_MID_MID = @{(CLOSE_CURLY_BRACKET_TOKEN ~ (STRING_CONTENT_SQ)* ~ INTERPOLATION_START_TOKEN)}

SINGLE_LINE_STRING_SQ_MID_END = @{(CLOSE_CURLY_BRACKET_TOKEN ~ (STRING_CONTENT_SQ)* ~ QUOTE_TOKEN)}

STRING_CONTENT_DQ = @{(STRING_CONTENT_COMMON | QUOTE_TOKEN)}

SINGLE_LINE_STRING_DQ_BEGIN_END = @{(DOUBLE_QUOTE_TOKEN ~ (STRING_CONTENT_DQ)* ~ DOUBLE_QUOTE_TOKEN)}

SINGLE_LINE_STRING_DQ_BEGIN_MID = @{(DOUBLE_QUOTE_TOKEN ~ (STRING_CONTENT_DQ)* ~ INTERPOLATION_START_TOKEN)}

SINGLE_LINE_STRING_DQ_MID_MID = @{(CLOSE_CURLY_BRACKET_TOKEN ~ (STRING_CONTENT_DQ)* ~ INTERPOLATION_START_TOKEN)}

SINGLE_LINE_STRING_DQ_MID_END = @{(CLOSE_CURLY_BRACKET_TOKEN ~ (STRING_CONTENT_DQ)* ~ DOUBLE_QUOTE_TOKEN)}

RAW_MULTI_LINE_STRING = @{((R_TOKEN ~ TRIPLE_QUOTES_TOKEN ~ ANY ~ TRIPLE_QUOTES_TOKEN) | (R_TOKEN ~ TRIPLE_DOUBLE_QUOTES_TOKEN ~ ANY ~ TRIPLE_DOUBLE_QUOTES_TOKEN))}

QUOTES_SQ = @{(QUOTE_TOKEN | TWO_QUOTES_TOKEN)}

STRING_CONTENT_TSQ = @{((QUOTES_SQ)? ~ (STRING_CONTENT_COMMON | DOUBLE_QUOTE_TOKEN | R_ESCAPE_TOKEN | NEWLINE_TOKEN))}

MULTI_LINE_STRING_SQ_BEGIN_END = @{(TRIPLE_QUOTES_TOKEN ~ (STRING_CONTENT_TSQ)* ~ TRIPLE_QUOTES_TOKEN)}

MULTI_LINE_STRING_SQ_BEGIN_MID = @{(TRIPLE_QUOTES_TOKEN ~ (STRING_CONTENT_TSQ)* ~ (QUOTES_SQ)? ~ INTERPOLATION_START_TOKEN)}

MULTI_LINE_STRING_SQ_MID_MID = @{(CLOSE_CURLY_BRACKET_TOKEN ~ (STRING_CONTENT_TSQ)* ~ (QUOTES_SQ)? ~ INTERPOLATION_START_TOKEN)}

MULTI_LINE_STRING_SQ_MID_END = @{(CLOSE_CURLY_BRACKET_TOKEN ~ (STRING_CONTENT_TSQ)* ~ TRIPLE_QUOTES_TOKEN)}

QUOTES_DQ = @{(DOUBLE_QUOTE_TOKEN | TWO_DOUBLE_QUOTES_TOKEN)}

STRING_CONTENT_TDQ = @{((QUOTES_DQ)? ~ (STRING_CONTENT_COMMON | QUOTE_TOKEN | R_ESCAPE_TOKEN | NEWLINE_TOKEN))}

MULTI_LINE_STRING_DQ_BEGIN_END = @{(TRIPLE_DOUBLE_QUOTES_TOKEN ~ (STRING_CONTENT_TDQ)* ~ TRIPLE_DOUBLE_QUOTES_TOKEN)}

MULTI_LINE_STRING_DQ_BEGIN_MID = @{(TRIPLE_DOUBLE_QUOTES_TOKEN ~ (STRING_CONTENT_TDQ)* ~ (QUOTES_DQ)? ~ INTERPOLATION_START_TOKEN)}

MULTI_LINE_STRING_DQ_MID_MID = @{(CLOSE_CURLY_BRACKET_TOKEN ~ (STRING_CONTENT_TDQ)* ~ (QUOTES_DQ)? ~ INTERPOLATION_START_TOKEN)}

MULTI_LINE_STRING_DQ_MID_END = @{(CLOSE_CURLY_BRACKET_TOKEN ~ (STRING_CONTENT_TDQ)* ~ TRIPLE_DOUBLE_QUOTES_TOKEN)}

ESCAPE_SEQUENCE = @{("\n" | "\r" | "\\f" | "\\b" | "\t" | "\\v" | ("\\x" ~ HEX_DIGIT ~ HEX_DIGIT) | ("\\u" ~ HEX_DIGIT ~ HEX_DIGIT ~ HEX_DIGIT ~ HEX_DIGIT) | ("\\u{" ~ HEX_DIGIT_SEQUENCE ~ "}"))}

HEX_DIGIT_SEQUENCE = @{(HEX_DIGIT ~ (HEX_DIGIT)? ~ (HEX_DIGIT)? ~ (HEX_DIGIT)? ~ (HEX_DIGIT)? ~ (HEX_DIGIT)?)}

NEWLINE = @{(NEWLINE_TOKEN | R_ESCAPE_TOKEN | RN_ESCAPE_TOKEN)}

SIMPLE_STRING_INTERPOLATION = @{(DOLLAR_TOKEN ~ (IDENTIFIER_NO_DOLLAR | BUILT_IN_IDENTIFIER | THIS_TOKEN))}

BUILT_IN_IDENTIFIER = @{(ABSTRACT_TOKEN | AS_TOKEN | COVARIANT_TOKEN | DEFERRED_TOKEN | DYNAMIC_TOKEN | EXPORT_TOKEN | EXTERNAL_TOKEN | EXTENSION_TOKEN | FACTORY_TOKEN | FUNCTION_TOKEN | GET_TOKEN | IMPLEMENTS_TOKEN | IMPORT_TOKEN | INTERFACE_TOKEN | LATE_TOKEN | LIBRARY_TOKEN | MIXIN_TOKEN | OPERATOR_TOKEN | PART_TOKEN | REQUIRED_TOKEN | SET_TOKEN | STATIC_TOKEN | TYPEDEF_TOKEN)}

OTHER_IDENTIFIER = @{(ASYNC_TOKEN | HIDE_TOKEN | OF_TOKEN | ON_TOKEN | SHOW_TOKEN | SYNC_TOKEN | AWAIT_TOKEN | YIELD_TOKEN)}

IDENTIFIER_NO_DOLLAR = @{(IDENTIFIER_START_NO_DOLLAR ~ (IDENTIFIER_PART_NO_DOLLAR)*)}

IDENTIFIER_START_NO_DOLLAR = @{(LETTER | UNDERSCORE_TOKEN)}

IDENTIFIER_PART_NO_DOLLAR = @{(IDENTIFIER_START_NO_DOLLAR | DIGIT)}

IDENTIFIER = @{!RESERVED_WORD ~ (IDENTIFIER_START ~ (IDENTIFIER_PART)*)}

IDENTIFIER_START = @{(IDENTIFIER_START_NO_DOLLAR | DOLLAR_TOKEN)}

IDENTIFIER_PART = @{(IDENTIFIER_START | DIGIT)}

LETTER = @{('a'..'z' | 'A'..'Z')}

DIGIT = @{'0'..'9'}

WHITESPACE = @{((T_ESCAPE_TOKEN | SPACE_TOKEN | NEWLINE))+}

SCRIPT_TAG_CONTENT = @{((!(NEWLINE) ~ ANY))*}

RESERVED_WORD = @{("assert" | "break" | "case" | "catch" | "class" | "const" | "continue" | "default" | "do" | "else" | "enum" | "extends" | "false" | "final" | "finally" | "for" | "if" | "in" | "is" | "new" | "null" | "rethrow" | "return" | "super" | "switch" | "this" | "throw" | "true" | "try" | "var" | "void" | "while" | "with") ~ !IDENTIFIER}

SINGLE_LINE_COMMENT = @{(COMMENT_TOKEN ~ ((!(NEWLINE) ~ ANY))* ~ (NEWLINE)?)}

MULTI_LINE_COMMENT = @{(COMMENT_MULTILINE_START_TOKEN ~ ((MULTI_LINE_COMMENT | (!(COMMENT_MULTILINE_END_TOKEN) ~ ANY)))* ~ COMMENT_MULTILINE_END_TOKEN)}

COMMENT = ${(SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT)}

LET_TOKEN = @{"let"}

IN_TOKEN = @{"in"}

LATE_TOKEN = @{"late"}

FINAL_TOKEN = @{"final"}

CONST_TOKEN = @{"const"}

VAR_TOKEN = @{"var"}

EQUAL_TOKEN = @{"="}

COMMA_TOKEN = @{","}

ASYNC_TOKEN = @{"async"}

ARROW_TOKEN = @{"=>"}

SEMICOLON_TOKEN = @{";"}

ASTERISK_TOKEN = @{"*"}

SYNC_TOKEN = @{"sync"}

OPEN_CURLY_BRACKET_TOKEN = @{"{"}

CLOSE_CURLY_BRACKET_TOKEN = @{"}"}

OPEN_PAREN_TOKEN = @{"("}

CLOSE_PAREN_TOKEN = @{")"}

OPEN_SQUARE_BRACKET_TOKEN = @{"["}

CLOSE_SQUARE_BRACKET_TOKEN = @{"]"}

COVARIANT_TOKEN = @{"covariant"}

QUESTION_TOKEN = @{"?"}

THIS_TOKEN = @{"this"}

PERIOD_TOKEN = @{"."}

COLON_TOKEN = @{":"}

REQUIRED_TOKEN = @{"required"}

ABSTRACT_TOKEN = @{"abstract"}

CLASS_TOKEN = @{"class"}

STATIC_TOKEN = @{"static"}

EXTERNAL_TOKEN = @{"external"}

OPERATOR_TOKEN = @{"operator"}

TILDE_TOKEN = @{"~"}

SQUARE_BRACKETS_TOKEN = @{"[]"}

QUARE_BRACKETS_EQ_TOKEN = @{"[]="}

DOUBLE_EQUAL_TOKEN = @{"=="}

GET_TOKEN = @{"get"}

SET_TOKEN = @{"set"}

SUPER_TOKEN = @{"super"}

FACTORY_TOKEN = @{"factory"}

EXTENDS_TOKEN = @{"extends"}

WITH_TOKEN = @{"with"}

IMPLEMENTS_TOKEN = @{"implements"}

ON_TOKEN = @{"on"}

MIXIN_TOKEN = @{"mixin"}

EXTENSION_TOKEN = @{"extension"}

ENUM_TOKEN = @{"enum"}

LESS_TOKEN = @{"<"}

MORE_TOKEN = @{">"}

AT_TOKEN = @{"@"}

NULL_TOKEN = @{"null"}

TRUE_TOKEN = @{"true"}

FALSE_TOKEN = @{"false"}

INTERPOLATION_START_TOKEN = @{"${"}

VOID_TOKEN = @{"void"}

HASH_TOKEN = @{"#"}

POINTS_EXPAND_TOKEN = @{"..."}

POINTS_EXPAND_QUESTION_TOKEN = @{"...?"}

ELSE_TOKEN = @{"else"}

IF_TOKEN = @{"if"}

AWAIT_TOKEN = @{"await"}

FOR_TOKEN = @{"for"}

THROW_TOKEN = @{"throw"}

NEW_TOKEN = @{"new"}

POINTS_ID_TOKEN = @{".."}

POINTS_ID_QUESTION_TOKEN = @{"?.."}

TIMES_EQUAL_TOKEN = @{"*="}

DIV_EQUAL_TOKEN = @{"/="}

INTEGER_DIV_EQUAL_TOKEN = @{"~/="}

MODULE_EQUAL_TOKEN = @{"%="}

PLUS_EQUAL_TOKEN = @{"+="}

MINUS_EQUAL_TOKEN = @{"-="}

BIT_LEFT_EQUAL_TOKEN = @{"<<="}

BIT_RIGHT0_EQUAL_TOKEN = @{">>>="}

BIT_RIGHT_EQUAL_TOKEN = @{">>="}

BIT_AND_EUQAL_TOKEN = @{"&="}

BIT_NEG_EQUAL_TOKEN = @{"^="}

BIT_XOR_EQUAL_TOKEN = @{"|="}

QUESTION_QUESTION_EQUAL_TOKEN = @{"??="}

QUESTION_QUESTION_TOKEN = @{"??"}

OR_TOKEN = @{"||"}

AND_TOKEN = @{"&&"}

NOT_EQUAL_TOKEN = @{"!="}

MORE_OR_EQUAL_TOKEN = @{">="}

LESS_OR_EQUAL_TOKEN = @{"<="}

BIT_XOR_TOKEN = @{"|"}

BIT_NEG_TOKEN = @{"^"}

BIT_AND_TOKEN = @{"&"}

BIT_LEFT_TOKEN = @{"<<"}

BIT_RIGHT0_TOKEN = @{">>>"}

BIT_RIGHT_TOKEN = @{">>"}

PLUS_TOKEN = @{"+"}

MINUS_TOKEN = @{"-"}

DIVIDE_TOKEN = @{"/"}

MODULUS_TOKEN = @{"%"}

INTEGER_DIV_TOKEN = @{"~/"}

EXCLAMATION_TOKEN = @{"!"}

PLUS_PLUS_TOKEN = @{"++"}

MINUS_MINUS_TOKEN = @{"--"}

QUESTION_ID_TOKEN = @{"?."}

DYNAMIC_TOKEN = @{"dynamic"}

IS_TOKEN = @{"is"}

AS_TOKEN = @{"as"}

WHILE_TOKEN = @{"while"}

DO_TOKEN = @{"do"}

SWITCH_TOKEN = @{"switch"}

CASE_TOKEN = @{"case"}

DEFAULT_TOKEN = @{"default"}

RETHROW_TOKEN = @{"rethrow"}

TRY_TOKEN = @{"try"}

CATCH_TOKEN = @{"catch"}

FINALLY_TOKEN = @{"finally"}

RETURN_TOKEN = @{"return"}

BREAK_TOKEN = @{"break"}

CONTINUE_TOKEN = @{"continue"}

YIELD_TOKEN = @{"yield"}

ASSERT_TOKEN = @{"assert"}

HASH_EXCLAMATION_TOKEN = @{"#!"}

LIBRARY_TOKEN = @{"library"}

DEFERRED_TOKEN = @{"deferred"}

IMPORT_TOKEN = @{"import"}

EXPORT_TOKEN = @{"export"}

SHOW_TOKEN = @{"show"}

HIDE_TOKEN = @{"hide"}

PART_TOKEN = @{"part"}

OF_TOKEN = @{"of"}

FUNCTION_TOKEN = @{"Function"}

TYPEDEF_TOKEN = @{"typedef"}

EXPONENT_TOKEN = @{"e"}

SCIENTIFIC_TOKEN = @{"E"}

HEX0X_TOKEN = @{"0x"}

HEX0_X_TOKEN = @{"0X"}

R_TOKEN = @{"r"}

QUOTE_TOKEN = @{"'"}

R_ESCAPE_TOKEN = @{"\r"}

NEWLINE_TOKEN = @{"\n"}

DOUBLE_QUOTE_TOKEN = @{"\""}

BACK_TOKEN = @{"\\"}

DOLLAR_TOKEN = @{"$"}

N_TOKEN = @{"n"}

B_TOKEN = @{"b"}

T_TOKEN = @{"t"}

V_TOKEN = @{"v"}

X_TOKEN = @{"x"}

U_TOKEN = @{"u"}

TRIPLE_QUOTES_TOKEN = @{"'''"}

TRIPLE_DOUBLE_QUOTES_TOKEN = @{"\"\"\""}

TWO_QUOTES_TOKEN = @{"''"}

TWO_DOUBLE_QUOTES_TOKEN = @{"\"\""}

RN_ESCAPE_TOKEN = @{"\r\n"}

INTERFACE_TOKEN = @{"interface"}

UNDERSCORE_TOKEN = @{"_"}

T_ESCAPE_TOKEN = @{"\t"}

SPACE_TOKEN = @{" "}

COMMENT_TOKEN = @{"//"}

COMMENT_MULTILINE_START_TOKEN = @{"/*"}

COMMENT_MULTILINE_END_TOKEN = @{"*/"}