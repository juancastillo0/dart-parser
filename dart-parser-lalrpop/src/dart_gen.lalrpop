use ast;
use parser::Token;

grammar;

pub LetExpression: LetExpression = {<let_token:LET_TOKEN> <static_final_declaration_list:StaticFinalDeclarationList> <in_token:IN_TOKEN> <expression:Expression> => LetExpression{<>}};

pub FinalConstVarOrTypeFinalToken: FinalConstVarOrTypeFinalToken = {<late_token:(LATE_TOKEN)?> <final_token:FINAL_TOKEN> <dart_type:(Type)?> => FinalConstVarOrTypeFinalToken{<>}};

pub FinalConstVarOrTypeConstToken: FinalConstVarOrTypeConstToken = {<const_token:CONST_TOKEN> <dart_type:(Type)?> => FinalConstVarOrTypeConstToken{<>}};

pub FinalConstVarOrTypeVarOrType: FinalConstVarOrTypeVarOrType = {<late_token:(LATE_TOKEN)?> <var_or_type:VarOrType> => FinalConstVarOrTypeVarOrType{<>}};

pub FinalConstVarOrType: FinalConstVarOrType = {FinalConstVarOrTypeFinalToken => FinalConstVarOrType::Final(<>), FinalConstVarOrTypeConstToken => FinalConstVarOrType::Const(<>), FinalConstVarOrTypeVarOrType => FinalConstVarOrType::VarOrType(<>)};

pub VarOrType: VarOrType = {VAR_TOKEN => VarOrType::Var(<>), Type => VarOrType::Type(<>)};

pub ExpressionEqual: ExpressionEqual = {<equal_token:EQUAL_TOKEN> <expression:Expression> => ExpressionEqual{<>}};

pub InitializedIdentifierItem: InitializedIdentifierItem = {<comma_token:COMMA_TOKEN> <initialized_identifier:InitializedIdentifier> => InitializedIdentifierItem{<>}};

pub InitializedVariableDeclaration: InitializedVariableDeclaration = {<declared_identifier:DeclaredIdentifier> <expression_equal:(ExpressionEqual)?> <initialized_identifier_item:(InitializedIdentifierItem)*> => InitializedVariableDeclaration{<>}};

pub ExpressionEqual: ExpressionEqual = {<equal_token:EQUAL_TOKEN> <expression:Expression> => ExpressionEqual{<>}};

pub InitializedIdentifier: InitializedIdentifier = {<identifier:Identifier> <expression_equal:(ExpressionEqual)?> => InitializedIdentifier{<>}};

pub InitializedIdentifierItem: InitializedIdentifierItem = {<comma_token:COMMA_TOKEN> <initialized_identifier:InitializedIdentifier> => InitializedIdentifierItem{<>}};

pub InitializedIdentifierList: InitializedIdentifierList = {<initialized_identifier:InitializedIdentifier> <initialized_identifier_item:(InitializedIdentifierItem)*> => InitializedIdentifierList{<>}};

pub FunctionSignature: FunctionSignature = {<dart_type:(Type)?> <identifier:Identifier> <formal_parameter_part:FormalParameterPart> => FunctionSignature{<>}};

pub FormalParameterPart: FormalParameterPart = {<type_parameters:(TypeParameters)?> <formal_parameter_list:FormalParameterList> => FormalParameterPart{<>}};

pub FunctionBodyArrowToken: FunctionBodyArrowToken = {<async_token:(ASYNC_TOKEN)?> <arrow_token:ARROW_TOKEN> <expression:Expression> <semicolon_token:SEMICOLON_TOKEN> => FunctionBodyArrowToken{<>}};

pub FunctionBodyGeneratorAsyncToken: FunctionBodyGeneratorAsyncToken = {<async_token:ASYNC_TOKEN> <asterisk_token:(ASTERISK_TOKEN)?> => FunctionBodyGeneratorAsyncToken{<>}};

pub FunctionBodyGeneratorSyncToken: FunctionBodyGeneratorSyncToken = {<sync_token:SYNC_TOKEN> <asterisk_token:ASTERISK_TOKEN> => FunctionBodyGeneratorSyncToken{<>}};

pub FunctionBodyGenerator: FunctionBodyGenerator = {FunctionBodyGeneratorAsyncToken => FunctionBodyGenerator::Async(<>), FunctionBodyGeneratorSyncToken => FunctionBodyGenerator::Sync(<>)};

pub FunctionBodyBlock: FunctionBodyBlock = {<function_body_generator:(FunctionBodyGenerator)?> <block:Block> => FunctionBodyBlock{<>}};

pub FunctionBody: FunctionBody = {FunctionBodyArrowToken => FunctionBody::Arrow(<>), FunctionBodyBlock => FunctionBody::Block(<>)};

pub Block: Block = {<open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <statements:Statements> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => Block{<>}};

pub EmptyParameters: EmptyParameters = {<open_paren_token:OPEN_PAREN_TOKEN> <close_paren_token:CLOSE_PAREN_TOKEN> => EmptyParameters{<>}};

pub FormalParameterListNormalFormalParameters: FormalParameterListNormalFormalParameters = {<open_paren_token:OPEN_PAREN_TOKEN> <normal_formal_parameters:NormalFormalParameters> <comma_token:(COMMA_TOKEN)?> <close_paren_token:CLOSE_PAREN_TOKEN> => FormalParameterListNormalFormalParameters{<>}};

pub NormalWithOptionalOrNamedParameters: NormalWithOptionalOrNamedParameters = {<open_paren_token:OPEN_PAREN_TOKEN> <normal_formal_parameters:NormalFormalParameters> <comma_token:COMMA_TOKEN> <optional_or_named_formal_parameters:OptionalOrNamedFormalParameters> <close_paren_token:CLOSE_PAREN_TOKEN> => NormalWithOptionalOrNamedParameters{<>}};

pub FormalParameterListOptionalOrNamedFormalParameters: FormalParameterListOptionalOrNamedFormalParameters = {<open_paren_token:OPEN_PAREN_TOKEN> <optional_or_named_formal_parameters:OptionalOrNamedFormalParameters> <close_paren_token:CLOSE_PAREN_TOKEN> => FormalParameterListOptionalOrNamedFormalParameters{<>}};

pub FormalParameterList: FormalParameterList = {EmptyParameters => FormalParameterList::EmptyParameters(<>), FormalParameterListNormalFormalParameters => FormalParameterList::NormalFormalParameters(<>), NormalWithOptionalOrNamedParameters => FormalParameterList::NormalWithOptionalOrNamedParameters(<>), FormalParameterListOptionalOrNamedFormalParameters => FormalParameterList::OptionalOrNamedFormalParameters(<>)};

pub NormalFormalParameterItem: NormalFormalParameterItem = {<comma_token:COMMA_TOKEN> <normal_formal_parameter:NormalFormalParameter> => NormalFormalParameterItem{<>}};

pub NormalFormalParameters: NormalFormalParameters = {<normal_formal_parameter:NormalFormalParameter> <normal_formal_parameter_item:(NormalFormalParameterItem)*> => NormalFormalParameters{<>}};

pub OptionalOrNamedFormalParameters: OptionalOrNamedFormalParameters = {OptionalPositionalFormalParameters => OptionalOrNamedFormalParameters::OptionalPositionalFormalParameters(<>), NamedFormalParameters => OptionalOrNamedFormalParameters::NamedFormalParameters(<>)};

pub DefaultFormalParameterItem: DefaultFormalParameterItem = {<comma_token:COMMA_TOKEN> <default_formal_parameter:DefaultFormalParameter> => DefaultFormalParameterItem{<>}};

pub OptionalPositionalFormalParameters: OptionalPositionalFormalParameters = {<open_square_bracket_token:OPEN_SQUARE_BRACKET_TOKEN> <default_formal_parameter:DefaultFormalParameter> <default_formal_parameter_item:(DefaultFormalParameterItem)*> <comma_token:(COMMA_TOKEN)?> <close_square_bracket_token:CLOSE_SQUARE_BRACKET_TOKEN> => OptionalPositionalFormalParameters{<>}};

pub DefaultNamedParameterItem: DefaultNamedParameterItem = {<comma_token:COMMA_TOKEN> <default_named_parameter:DefaultNamedParameter> => DefaultNamedParameterItem{<>}};

pub NamedFormalParameters: NamedFormalParameters = {<open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <default_named_parameter:DefaultNamedParameter> <default_named_parameter_item:(DefaultNamedParameterItem)*> <comma_token:(COMMA_TOKEN)?> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => NamedFormalParameters{<>}};

pub NormalFormalParameter: NormalFormalParameter = {<metadata:Metadata> <normal_formal_parameter_no_metadata:NormalFormalParameterNoMetadata> => NormalFormalParameter{<>}};

pub NormalFormalParameterNoMetadata: NormalFormalParameterNoMetadata = {FunctionFormalParameter => NormalFormalParameterNoMetadata::FunctionFormalParameter(<>), FieldFormalParameter => NormalFormalParameterNoMetadata::FieldFormalParameter(<>), SimpleFormalParameter => NormalFormalParameterNoMetadata::SimpleFormalParameter(<>), SuperFormalParameter => NormalFormalParameterNoMetadata::SuperFormalParameter(<>)};

pub FunctionFormalParameter: FunctionFormalParameter = {<covariant_token:(COVARIANT_TOKEN)?> <dart_type:(Type)?> <identifier:Identifier> <formal_parameter_part:FormalParameterPart> <question_token:(QUESTION_TOKEN)?> => FunctionFormalParameter{<>}};

pub SimpleFormalParameterIdentifier: SimpleFormalParameterIdentifier = {<covariant_token:(COVARIANT_TOKEN)?> <identifier:Identifier> => SimpleFormalParameterIdentifier{<>}};

pub SimpleFormalParameter: SimpleFormalParameter = {DeclaredIdentifier => SimpleFormalParameter::DeclaredIdentifier(<>), SimpleFormalParameterIdentifier => SimpleFormalParameter::Identifier(<>)};

pub DeclaredIdentifier: DeclaredIdentifier = {<covariant_token:(COVARIANT_TOKEN)?> <final_const_var_or_type:FinalConstVarOrType> <identifier:Identifier> => DeclaredIdentifier{<>}};

pub FieldFormalParameterFormalParameterPart: FieldFormalParameterFormalParameterPart = {<formal_parameter_part:FormalParameterPart> <question_token:(QUESTION_TOKEN)?> => FieldFormalParameterFormalParameterPart{<>}};

pub FieldFormalParameter: FieldFormalParameter = {<final_const_var_or_type:(FinalConstVarOrType)?> <this_token:THIS_TOKEN> <period_token:PERIOD_TOKEN> <identifier:Identifier> <formal_parameter_part:(FieldFormalParameterFormalParameterPart)?> => FieldFormalParameter{<>}};

pub SuperFormalParameterFormalParameterPart: SuperFormalParameterFormalParameterPart = {<formal_parameter_part:FormalParameterPart> <question_token:(QUESTION_TOKEN)?> => SuperFormalParameterFormalParameterPart{<>}};

pub SuperFormalParameter: SuperFormalParameter = {<final_const_var_or_type:(FinalConstVarOrType)?> <super_token:SUPER_TOKEN> <period_token:PERIOD_TOKEN> <identifier:Identifier> <formal_parameter_part:(SuperFormalParameterFormalParameterPart)?> => SuperFormalParameter{<>}};

pub ExpressionEqual: ExpressionEqual = {<equal_token:EQUAL_TOKEN> <expression:Expression> => ExpressionEqual{<>}};

pub DefaultFormalParameter: DefaultFormalParameter = {<normal_formal_parameter:NormalFormalParameter> <expression_equal:(ExpressionEqual)?> => DefaultFormalParameter{<>}};

pub EqualTokenOrColonToken: EqualTokenOrColonToken = {EQUAL_TOKEN => EqualTokenOrColonToken::Equal(<>), COLON_TOKEN => EqualTokenOrColonToken::Colon(<>)};

pub DefaultNamedParameterAssignment: DefaultNamedParameterAssignment = {<equal_token_or_colon_token:EqualTokenOrColonToken> <expression:Expression> => DefaultNamedParameterAssignment{<>}};

pub DefaultNamedParameter: DefaultNamedParameter = {<metadata:Metadata> <required_token:(REQUIRED_TOKEN)?> <normal_formal_parameter_no_metadata:NormalFormalParameterNoMetadata> <default_named_parameter_assignment:(DefaultNamedParameterAssignment)?> => DefaultNamedParameter{<>}};

pub ClassDeclarationMembers: ClassDeclarationMembers = {<metadata:Metadata> <class_member_declaration:ClassMemberDeclaration> => ClassDeclarationMembers{<>}};

pub ClassDeclarationClassToken: ClassDeclarationClassToken = {<abstract_token:(ABSTRACT_TOKEN)?> <class_token:CLASS_TOKEN> <type_identifier:TypeIdentifier> <type_parameters:(TypeParameters)?> <superclass:(Superclass)?> <interfaces:(Interfaces)?> <open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <class_declaration_members:(ClassDeclarationMembers)*> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => ClassDeclarationClassToken{<>}};

pub ClassDeclarationMixin: ClassDeclarationMixin = {<abstract_token:(ABSTRACT_TOKEN)?> <class_token:CLASS_TOKEN> <mixin_application_class:MixinApplicationClass> => ClassDeclarationMixin{<>}};

pub ClassDeclaration: ClassDeclaration = {ClassDeclarationClassToken => ClassDeclaration::Class(<>), ClassDeclarationMixin => ClassDeclaration::ClassDeclarationMixin(<>)};

pub TypeNotVoidItem: TypeNotVoidItem = {<comma_token:COMMA_TOKEN> <type_not_void:TypeNotVoid> => TypeNotVoidItem{<>}};

pub TypeNotVoidList: TypeNotVoidList = {<type_not_void:TypeNotVoid> <type_not_void_item:(TypeNotVoidItem)*> => TypeNotVoidList{<>}};

pub ClassMemberDeclarationSemicolonToken: ClassMemberDeclarationSemicolonToken = {<declaration:Declaration> <semicolon_token:SEMICOLON_TOKEN> => ClassMemberDeclarationSemicolonToken{<>}};

pub ClassMemberDeclarationMethodSignature: ClassMemberDeclarationMethodSignature = {<method_signature:MethodSignature> <function_body:FunctionBody> => ClassMemberDeclarationMethodSignature{<>}};

pub ClassMemberDeclaration: ClassMemberDeclaration = {ClassMemberDeclarationSemicolonToken => ClassMemberDeclaration::Semicolon(<>), ClassMemberDeclarationMethodSignature => ClassMemberDeclaration::MethodSignature(<>)};

pub MethodSignatureConstructorSignature: MethodSignatureConstructorSignature = {<constructor_signature:ConstructorSignature> <initializers:(Initializers)?> => MethodSignatureConstructorSignature{<>}};

pub MethodSignatureFunctionSignature: MethodSignatureFunctionSignature = {<static_token:(STATIC_TOKEN)?> <function_signature:FunctionSignature> => MethodSignatureFunctionSignature{<>}};

pub MethodSignatureGetterSignature: MethodSignatureGetterSignature = {<static_token:(STATIC_TOKEN)?> <getter_signature:GetterSignature> => MethodSignatureGetterSignature{<>}};

pub MethodSignatureSetterSignature: MethodSignatureSetterSignature = {<static_token:(STATIC_TOKEN)?> <setter_signature:SetterSignature> => MethodSignatureSetterSignature{<>}};

pub MethodSignature: MethodSignature = {MethodSignatureConstructorSignature => MethodSignature::ConstructorSignature(<>), FactoryConstructorSignature => MethodSignature::FactoryConstructorSignature(<>), MethodSignatureFunctionSignature => MethodSignature::FunctionSignature(<>), MethodSignatureGetterSignature => MethodSignature::GetterSignature(<>), MethodSignatureSetterSignature => MethodSignature::SetterSignature(<>), OperatorSignature => MethodSignature::OperatorSignature(<>)};

pub DeclarationFactoryConstructorSignature: DeclarationFactoryConstructorSignature = {<external_token:EXTERNAL_TOKEN> <factory_constructor_signature:FactoryConstructorSignature> => DeclarationFactoryConstructorSignature{<>}};

pub ExternalConstantConstructorSignature: ExternalConstantConstructorSignature = {<external_token:EXTERNAL_TOKEN> <constant_constructor_signature:ConstantConstructorSignature> => ExternalConstantConstructorSignature{<>}};

pub ExternalConstructorSignature: ExternalConstructorSignature = {<external_token:EXTERNAL_TOKEN> <constructor_signature:ConstructorSignature> => ExternalConstructorSignature{<>}};

pub ExternalMaybeStatic: ExternalMaybeStatic = {<external_token:EXTERNAL_TOKEN> <static_token:(STATIC_TOKEN)?> => ExternalMaybeStatic{<>}};

pub DeclarationGetterSignature: DeclarationGetterSignature = {<external_maybe_static:(ExternalMaybeStatic)?> <getter_signature:GetterSignature> => DeclarationGetterSignature{<>}};

pub ExternalMaybeStatic: ExternalMaybeStatic = {<external_token:EXTERNAL_TOKEN> <static_token:(STATIC_TOKEN)?> => ExternalMaybeStatic{<>}};

pub DeclarationSetterSignature: DeclarationSetterSignature = {<external_maybe_static:(ExternalMaybeStatic)?> <setter_signature:SetterSignature> => DeclarationSetterSignature{<>}};

pub ExternalMaybeStatic: ExternalMaybeStatic = {<external_token:EXTERNAL_TOKEN> <static_token:(STATIC_TOKEN)?> => ExternalMaybeStatic{<>}};

pub DeclarationFunctionSignature: DeclarationFunctionSignature = {<external_maybe_static:(ExternalMaybeStatic)?> <function_signature:FunctionSignature> => DeclarationFunctionSignature{<>}};

pub DeclarationOperatorSignature: DeclarationOperatorSignature = {<external_token:(EXTERNAL_TOKEN)?> <operator_signature:OperatorSignature> => DeclarationOperatorSignature{<>}};

pub StaticConst: StaticConst = {<static_token:STATIC_TOKEN> <const_token:CONST_TOKEN> <dart_type:(Type)?> <static_final_declaration_list:StaticFinalDeclarationList> => StaticConst{<>}};

pub StaticFinal: StaticFinal = {<static_token:STATIC_TOKEN> <final_token:FINAL_TOKEN> <dart_type:(Type)?> <static_final_declaration_list:StaticFinalDeclarationList> => StaticFinal{<>}};

pub StaticLateFinal: StaticLateFinal = {<static_token:STATIC_TOKEN> <late_token:LATE_TOKEN> <final_token:FINAL_TOKEN> <dart_type:(Type)?> <initialized_identifier_list:InitializedIdentifierList> => StaticLateFinal{<>}};

pub StaticVarOrType: StaticVarOrType = {<static_token:STATIC_TOKEN> <late_token:(LATE_TOKEN)?> <var_or_type:VarOrType> <initialized_identifier_list:InitializedIdentifierList> => StaticVarOrType{<>}};

pub CovariantLateFinal: CovariantLateFinal = {<covariant_token:COVARIANT_TOKEN> <late_token:LATE_TOKEN> <final_token:FINAL_TOKEN> <dart_type:(Type)?> <identifier_list:IdentifierList> => CovariantLateFinal{<>}};

pub CovariantVarOrType: CovariantVarOrType = {<covariant_token:COVARIANT_TOKEN> <late_token:(LATE_TOKEN)?> <var_or_type:VarOrType> <initialized_identifier_list:InitializedIdentifierList> => CovariantVarOrType{<>}};

pub DeclarationFinalToken: DeclarationFinalToken = {<late_token:(LATE_TOKEN)?> <final_token:FINAL_TOKEN> <dart_type:(Type)?> <initialized_identifier_list:InitializedIdentifierList> => DeclarationFinalToken{<>}};

pub DeclarationVarOrType: DeclarationVarOrType = {<late_token:(LATE_TOKEN)?> <var_or_type:VarOrType> <initialized_identifier_list:InitializedIdentifierList> => DeclarationVarOrType{<>}};

pub RedirectionOrInitializers: RedirectionOrInitializers = {Redirection => RedirectionOrInitializers::Redirection(<>), Initializers => RedirectionOrInitializers::Initializers(<>)};

pub DeclarationConstantConstructorSignature: DeclarationConstantConstructorSignature = {<constant_constructor_signature:ConstantConstructorSignature> <redirection_or_initializers:(RedirectionOrInitializers)?> => DeclarationConstantConstructorSignature{<>}};

pub RedirectionOrInitializers: RedirectionOrInitializers = {Redirection => RedirectionOrInitializers::Redirection(<>), Initializers => RedirectionOrInitializers::Initializers(<>)};

pub DeclarationConstructorSignature: DeclarationConstructorSignature = {<constructor_signature:ConstructorSignature> <redirection_or_initializers:(RedirectionOrInitializers)?> => DeclarationConstructorSignature{<>}};

pub Declaration: Declaration = {DeclarationFactoryConstructorSignature => Declaration::FactoryConstructorSignature(<>), ExternalConstantConstructorSignature => Declaration::ExternalConstantConstructorSignature(<>), ExternalConstructorSignature => Declaration::ExternalConstructorSignature(<>), DeclarationGetterSignature => Declaration::GetterSignature(<>), DeclarationSetterSignature => Declaration::SetterSignature(<>), DeclarationFunctionSignature => Declaration::FunctionSignature(<>), DeclarationOperatorSignature => Declaration::OperatorSignature(<>), StaticConst => Declaration::StaticConst(<>), StaticFinal => Declaration::StaticFinal(<>), StaticLateFinal => Declaration::StaticLateFinal(<>), StaticVarOrType => Declaration::StaticVarOrType(<>), CovariantLateFinal => Declaration::CovariantLateFinal(<>), CovariantVarOrType => Declaration::CovariantVarOrType(<>), DeclarationFinalToken => Declaration::Final(<>), DeclarationVarOrType => Declaration::VarOrType(<>), RedirectingFactoryConstructorSignature => Declaration::RedirectingFactoryConstructorSignature(<>), DeclarationConstantConstructorSignature => Declaration::ConstantConstructorSignature(<>), DeclarationConstructorSignature => Declaration::ConstructorSignature(<>)};

pub StaticFinalDeclarationItem: StaticFinalDeclarationItem = {<comma_token:COMMA_TOKEN> <static_final_declaration:StaticFinalDeclaration> => StaticFinalDeclarationItem{<>}};

pub StaticFinalDeclarationList: StaticFinalDeclarationList = {<static_final_declaration:StaticFinalDeclaration> <static_final_declaration_item:(StaticFinalDeclarationItem)*> => StaticFinalDeclarationList{<>}};

pub StaticFinalDeclaration: StaticFinalDeclaration = {<identifier:Identifier> <equal_token:EQUAL_TOKEN> <expression:Expression> => StaticFinalDeclaration{<>}};

pub OperatorSignature: OperatorSignature = {<dart_type:(Type)?> <operator_token:OPERATOR_TOKEN> <operator:Operator> <formal_parameter_list:FormalParameterList> => OperatorSignature{<>}};

pub Operator: Operator = {TILDE_TOKEN => Operator::Tilde(<>), BinaryOperator => Operator::BinaryOperator(<>), SQUARE_BRACKETS_TOKEN => Operator::SquareBrackets(<>), SQUARE_BRACKETS_EQ_TOKEN => Operator::SquareBracketsEq(<>)};

pub BinaryOperator: BinaryOperator = {MultiplicativeOperator => BinaryOperator::MultiplicativeOperator(<>), AdditiveOperator => BinaryOperator::AdditiveOperator(<>), ShiftOperator => BinaryOperator::ShiftOperator(<>), RelationalOperator => BinaryOperator::RelationalOperator(<>), DOUBLE_EQUAL_TOKEN => BinaryOperator::DoubleEqual(<>), BitwiseOperator => BinaryOperator::BitwiseOperator(<>)};

pub GetterSignature: GetterSignature = {<dart_type:(Type)?> <get_token:GET_TOKEN> <identifier:Identifier> => GetterSignature{<>}};

pub SetterSignature: SetterSignature = {<dart_type:(Type)?> <set_token:SET_TOKEN> <identifier:Identifier> <formal_parameter_list:FormalParameterList> => SetterSignature{<>}};

pub ConstructorSignature: ConstructorSignature = {<constructor_name:ConstructorName> <formal_parameter_list:FormalParameterList> => ConstructorSignature{<>}};

pub IdentifierOrNewSelector: IdentifierOrNewSelector = {<period_token:PERIOD_TOKEN> <identifier_or_new:IdentifierOrNew> => IdentifierOrNewSelector{<>}};

pub ConstructorName: ConstructorName = {<type_identifier:TypeIdentifier> <identifier_or_new_selector:(IdentifierOrNewSelector)?> => ConstructorName{<>}};

pub IdentifierOrNewSelector: IdentifierOrNewSelector = {<period_token:PERIOD_TOKEN> <identifier_or_new:IdentifierOrNew> => IdentifierOrNewSelector{<>}};

pub Redirection: Redirection = {<colon_token:COLON_TOKEN> <this_token:THIS_TOKEN> <identifier_or_new_selector:(IdentifierOrNewSelector)?> <arguments:Arguments> => Redirection{<>}};

pub InitializerListEntryItem: InitializerListEntryItem = {<comma_token:COMMA_TOKEN> <initializer_list_entry:InitializerListEntry> => InitializerListEntryItem{<>}};

pub Initializers: Initializers = {<colon_token:COLON_TOKEN> <initializer_list_entry:InitializerListEntry> <initializer_list_entry_item:(InitializerListEntryItem)*> => Initializers{<>}};

pub InitializerListEntryArguments: InitializerListEntryArguments = {<super_token:SUPER_TOKEN> <arguments:Arguments> => InitializerListEntryArguments{<>}};

pub InitializerListEntrySuperToken: InitializerListEntrySuperToken = {<super_token:SUPER_TOKEN> <period_token:PERIOD_TOKEN> <identifier_or_new:IdentifierOrNew> <arguments:Arguments> => InitializerListEntrySuperToken{<>}};

pub InitializerListEntry: InitializerListEntry = {InitializerListEntryArguments => InitializerListEntry::Arguments(<>), InitializerListEntrySuperToken => InitializerListEntry::Super(<>), FieldInitializer => InitializerListEntry::FieldInitializer(<>), Assertion => InitializerListEntry::Assertion(<>)};

pub FieldInitializerThisToken: FieldInitializerThisToken = {<this_token:THIS_TOKEN> <period_token:PERIOD_TOKEN> => FieldInitializerThisToken{<>}};

pub FieldInitializer: FieldInitializer = {<this_token:(FieldInitializerThisToken)?> <identifier:Identifier> <equal_token:EQUAL_TOKEN> <initializer_expression:InitializerExpression> => FieldInitializer{<>}};

pub InitializerExpression: InitializerExpression = {ConditionalExpression => InitializerExpression::ConditionalExpression(<>), Cascade => InitializerExpression::Cascade(<>)};

pub FactoryConstructorSignature: FactoryConstructorSignature = {<const_token:(CONST_TOKEN)?> <factory_token:FACTORY_TOKEN> <constructor_name:ConstructorName> <formal_parameter_list:FormalParameterList> => FactoryConstructorSignature{<>}};

pub RedirectingFactoryConstructorSignature: RedirectingFactoryConstructorSignature = {<const_token:(CONST_TOKEN)?> <factory_token:FACTORY_TOKEN> <constructor_name:ConstructorName> <formal_parameter_list:FormalParameterList> <equal_token:EQUAL_TOKEN> <constructor_designation:ConstructorDesignation> => RedirectingFactoryConstructorSignature{<>}};

pub IdentifierOrNewSelector: IdentifierOrNewSelector = {<period_token:PERIOD_TOKEN> <identifier_or_new:IdentifierOrNew> => IdentifierOrNewSelector{<>}};

pub ConstructorDesignationTypeName: ConstructorDesignationTypeName = {<type_name:TypeName> <type_arguments:TypeArguments> <identifier_or_new_selector:(IdentifierOrNewSelector)?> => ConstructorDesignationTypeName{<>}};

pub ConstructorDesignation: ConstructorDesignation = {TypeIdentifier => ConstructorDesignation::TypeIdentifier(<>), QualifiedName => ConstructorDesignation::QualifiedName(<>), ConstructorDesignationTypeName => ConstructorDesignation::TypeName(<>)};

pub ConstantConstructorSignature: ConstantConstructorSignature = {<const_token:CONST_TOKEN> <constructor_name:ConstructorName> <formal_parameter_list:FormalParameterList> => ConstantConstructorSignature{<>}};

pub SuperclassTypeNotVoid: SuperclassTypeNotVoid = {<extends_token:EXTENDS_TOKEN> <type_not_void:TypeNotVoid> <mixins:(Mixins)?> => SuperclassTypeNotVoid{<>}};

pub Superclass: Superclass = {SuperclassTypeNotVoid => Superclass::TypeNotVoid(<>), Mixins => Superclass::Mixins(<>)};

pub Mixins: Mixins = {<with_token:WITH_TOKEN> <type_not_void_list:TypeNotVoidList> => Mixins{<>}};

pub Interfaces: Interfaces = {<implements_token:IMPLEMENTS_TOKEN> <type_not_void_list:TypeNotVoidList> => Interfaces{<>}};

pub MixinApplicationClass: MixinApplicationClass = {<identifier:Identifier> <type_parameters:(TypeParameters)?> <equal_token:EQUAL_TOKEN> <mixin_application:MixinApplication> <semicolon_token:SEMICOLON_TOKEN> => MixinApplicationClass{<>}};

pub MixinApplication: MixinApplication = {<type_not_void:TypeNotVoid> <mixins:Mixins> <interfaces:(Interfaces)?> => MixinApplication{<>}};

pub TypeNotVoidListOn: TypeNotVoidListOn = {<on_token:ON_TOKEN> <type_not_void_list:TypeNotVoidList> => TypeNotVoidListOn{<>}};

pub MixinDeclarationMetadata: MixinDeclarationMetadata = {<metadata:Metadata> <class_member_declaration:ClassMemberDeclaration> => MixinDeclarationMetadata{<>}};

pub MixinDeclaration: MixinDeclaration = {<mixin_token:MIXIN_TOKEN> <type_identifier:TypeIdentifier> <type_parameters:(TypeParameters)?> <type_not_void_list_on:(TypeNotVoidListOn)?> <interfaces:(Interfaces)?> <open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <metadata:(MixinDeclarationMetadata)*> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => MixinDeclaration{<>}};

pub ExtensionDeclarationMetadata: ExtensionDeclarationMetadata = {<metadata:Metadata> <class_member_declaration:ClassMemberDeclaration> => ExtensionDeclarationMetadata{<>}};

pub ExtensionDeclaration: ExtensionDeclaration = {<extension_token:EXTENSION_TOKEN> <identifier:(Identifier)?> <type_parameters:(TypeParameters)?> <on_token:ON_TOKEN> <dart_type:Type> <open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <metadata:(ExtensionDeclarationMetadata)*> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => ExtensionDeclaration{<>}};

pub EnumEntryItem: EnumEntryItem = {<comma_token:COMMA_TOKEN> <enum_entry:EnumEntry> => EnumEntryItem{<>}};

pub EnumTypeMembersMetadata: EnumTypeMembersMetadata = {<metadata:Metadata> <class_member_declaration:ClassMemberDeclaration> => EnumTypeMembersMetadata{<>}};

pub EnumTypeMembers: EnumTypeMembers = {<semicolon_token:SEMICOLON_TOKEN> <metadata:(EnumTypeMembersMetadata)*> => EnumTypeMembers{<>}};

pub EnumType: EnumType = {<enum_token:ENUM_TOKEN> <type_identifier:TypeIdentifier> <type_parameters:(TypeParameters)?> <mixins:(Mixins)?> <interfaces:(Interfaces)?> <open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <enum_entry:EnumEntry> <enum_entry_item:(EnumEntryItem)*> <comma_token:(COMMA_TOKEN)?> <enum_type_members:(EnumTypeMembers)?> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => EnumType{<>}};

pub NamedEnumEntry: NamedEnumEntry = {<metadata:Metadata> <identifier:Identifier> <type_arguments:(TypeArguments)?> <period_token:PERIOD_TOKEN> <identifier2:Identifier> <arguments:Arguments> => NamedEnumEntry{<>}};

pub UnnamedEnumEntry: UnnamedEnumEntry = {<metadata:Metadata> <identifier:Identifier> <argument_part:(ArgumentPart)?> => UnnamedEnumEntry{<>}};

pub EnumEntry: EnumEntry = {NamedEnumEntry => EnumEntry::NamedEnumEntry(<>), UnnamedEnumEntry => EnumEntry::UnnamedEnumEntry(<>)};

pub TypeNotVoidExtends: TypeNotVoidExtends = {<extends_token:EXTENDS_TOKEN> <type_not_void:TypeNotVoid> => TypeNotVoidExtends{<>}};

pub TypeParameter: TypeParameter = {<metadata:Metadata> <identifier:Identifier> <type_not_void_extends:(TypeNotVoidExtends)?> => TypeParameter{<>}};

pub TypeParameterItem: TypeParameterItem = {<comma_token:COMMA_TOKEN> <type_parameter:TypeParameter> => TypeParameterItem{<>}};

pub TypeParameters: TypeParameters = {<less_token:LESS_TOKEN> <type_parameter:TypeParameter> <type_parameter_item:(TypeParameterItem)*> <more_token:MORE_TOKEN> => TypeParameters{<>}};

pub MetadataItem: MetadataItem = {<at_token:AT_TOKEN> <metadatum:Metadatum> => MetadataItem{<>}};

pub Metadata: Metadata = {(MetadataItem)* => Metadata(<>)};

pub MetadatumConstructorDesignation: MetadatumConstructorDesignation = {<constructor_designation:ConstructorDesignation> <arguments:Arguments> => MetadatumConstructorDesignation{<>}};

pub Metadatum: Metadatum = {Identifier => Metadatum::Identifier(<>), QualifiedName => Metadatum::QualifiedName(<>), MetadatumConstructorDesignation => Metadatum::ConstructorDesignation(<>)};

pub ExpressionAssignableExpression: ExpressionAssignableExpression = {<assignable_expression:AssignableExpression> <assignment_operator:AssignmentOperator> <expression:Expression> => ExpressionAssignableExpression{<>}};

pub Expression: Expression = {ExpressionAssignableExpression => Expression::AssignableExpression(<>), ConditionalExpression => Expression::ConditionalExpression(<>), Cascade => Expression::Cascade(<>), ThrowExpression => Expression::ThrowExpression(<>)};

pub ExpressionWithoutCascadeAssignableExpression: ExpressionWithoutCascadeAssignableExpression = {<assignable_expression:AssignableExpression> <assignment_operator:AssignmentOperator> <expression_without_cascade:ExpressionWithoutCascade> => ExpressionWithoutCascadeAssignableExpression{<>}};

pub ExpressionWithoutCascade: ExpressionWithoutCascade = {ExpressionWithoutCascadeAssignableExpression => ExpressionWithoutCascade::AssignableExpression(<>), ConditionalExpression => ExpressionWithoutCascade::ConditionalExpression(<>), ThrowExpressionWithoutCascade => ExpressionWithoutCascade::ThrowExpressionWithoutCascade(<>)};

pub ExpressionItem: ExpressionItem = {<comma_token:COMMA_TOKEN> <expression:Expression> => ExpressionItem{<>}};

pub ExpressionList: ExpressionList = {<expression:Expression> <expression_item:(ExpressionItem)*> => ExpressionList{<>}};

pub PrimaryUnconditionalAssignableSelector: PrimaryUnconditionalAssignableSelector = {<super_token:SUPER_TOKEN> <unconditional_assignable_selector:UnconditionalAssignableSelector> => PrimaryUnconditionalAssignableSelector{<>}};

pub PrimaryArgumentPart: PrimaryArgumentPart = {<super_token:SUPER_TOKEN> <argument_part:ArgumentPart> => PrimaryArgumentPart{<>}};

pub PrimaryExpression: PrimaryExpression = {<open_paren_token:OPEN_PAREN_TOKEN> <expression:Expression> <close_paren_token:CLOSE_PAREN_TOKEN> => PrimaryExpression{<>}};

pub Primary: Primary = {ThisExpression => Primary::ThisExpression(<>), PrimaryUnconditionalAssignableSelector => Primary::UnconditionalAssignableSelector(<>), PrimaryArgumentPart => Primary::ArgumentPart(<>), FunctionExpression => Primary::FunctionExpression(<>), NewExpression => Primary::NewExpression(<>), ConstObjectExpression => Primary::ConstObjectExpression(<>), ConstructorInvocation => Primary::ConstructorInvocation(<>), ConstructorTearoff => Primary::ConstructorTearoff(<>), PrimaryExpression => Primary::Expression(<>), Literal => Primary::Literal(<>), Identifier => Primary::Identifier(<>)};

pub Literal: Literal = {NullLiteral => Literal::NullLiteral(<>), BooleanLiteral => Literal::BooleanLiteral(<>), NumericLiteral => Literal::NumericLiteral(<>), StringLiteral => Literal::StringLiteral(<>), SymbolLiteral => Literal::SymbolLiteral(<>), ListLiteral => Literal::ListLiteral(<>), SetOrMapLiteral => Literal::SetOrMapLiteral(<>)};

pub NullLiteral: NullLiteral = {NULL_TOKEN};

pub NumericLiteral: NumericLiteral = {NUMBER => NumericLiteral::Number(<>), HEX_NUMBER => NumericLiteral::HexNumber(<>)};

pub BooleanLiteral: BooleanLiteral = {TRUE_TOKEN => BooleanLiteral::True(<>), FALSE_TOKEN => BooleanLiteral::False(<>)};

pub StringLiteralItem: StringLiteralItem = {MultilineString => StringLiteralItem::MultilineString(<>), SingleLineString => StringLiteralItem::SingleLineString(<>)};

pub StringLiteral: StringLiteral = {(StringLiteralItem)+ => StringLiteral(<>)};

pub ExpressionSingleLineStringSqMidMid: ExpressionSingleLineStringSqMidMid = {<single_line_string_sq_mid_mid:SINGLE_LINE_STRING_SQ_MID_MID> <expression:Expression> => ExpressionSingleLineStringSqMidMid{<>}};

pub SingleLineStringSingleLineStringSqBeginMid: SingleLineStringSingleLineStringSqBeginMid = {<single_line_string_sq_begin_mid:SINGLE_LINE_STRING_SQ_BEGIN_MID> <expression:Expression> <expression_single_line_string_sq_mid_mid:(ExpressionSingleLineStringSqMidMid)*> <single_line_string_sq_mid_end:SINGLE_LINE_STRING_SQ_MID_END> => SingleLineStringSingleLineStringSqBeginMid{<>}};

pub ExpressionSingleLineStringDqMidMid: ExpressionSingleLineStringDqMidMid = {<single_line_string_dq_mid_mid:SINGLE_LINE_STRING_DQ_MID_MID> <expression:Expression> => ExpressionSingleLineStringDqMidMid{<>}};

pub SingleLineStringSingleLineStringDqBeginMid: SingleLineStringSingleLineStringDqBeginMid = {<single_line_string_dq_begin_mid:SINGLE_LINE_STRING_DQ_BEGIN_MID> <expression:Expression> <expression_single_line_string_dq_mid_mid:(ExpressionSingleLineStringDqMidMid)*> <single_line_string_dq_mid_end:SINGLE_LINE_STRING_DQ_MID_END> => SingleLineStringSingleLineStringDqBeginMid{<>}};

pub SingleLineString: SingleLineString = {RAW_SINGLE_LINE_STRING => SingleLineString::RawSingleLineString(<>), SINGLE_LINE_STRING_SQ_BEGIN_END => SingleLineString::SingleLineStringSqBeginEnd(<>), SingleLineStringSingleLineStringSqBeginMid => SingleLineString::SingleLineStringSqBeginMid(<>), SINGLE_LINE_STRING_DQ_BEGIN_END => SingleLineString::SingleLineStringDqBeginEnd(<>), SingleLineStringSingleLineStringDqBeginMid => SingleLineString::SingleLineStringDqBeginMid(<>)};

pub ExpressionMultiLineStringSqMidMid: ExpressionMultiLineStringSqMidMid = {<multi_line_string_sq_mid_mid:MULTI_LINE_STRING_SQ_MID_MID> <expression:Expression> => ExpressionMultiLineStringSqMidMid{<>}};

pub MultilineStringMultiLineStringSqBeginMid: MultilineStringMultiLineStringSqBeginMid = {<multi_line_string_sq_begin_mid:MULTI_LINE_STRING_SQ_BEGIN_MID> <expression:Expression> <expression_multi_line_string_sq_mid_mid:(ExpressionMultiLineStringSqMidMid)*> <multi_line_string_sq_mid_end:MULTI_LINE_STRING_SQ_MID_END> => MultilineStringMultiLineStringSqBeginMid{<>}};

pub ExpressionMultiLineStringDqMidMid: ExpressionMultiLineStringDqMidMid = {<multi_line_string_dq_mid_mid:MULTI_LINE_STRING_DQ_MID_MID> <expression:Expression> => ExpressionMultiLineStringDqMidMid{<>}};

pub MultilineStringMultiLineStringDqBeginMid: MultilineStringMultiLineStringDqBeginMid = {<multi_line_string_dq_begin_mid:MULTI_LINE_STRING_DQ_BEGIN_MID> <expression:Expression> <expression_multi_line_string_dq_mid_mid:(ExpressionMultiLineStringDqMidMid)*> <multi_line_string_dq_mid_end:MULTI_LINE_STRING_DQ_MID_END> => MultilineStringMultiLineStringDqBeginMid{<>}};

pub MultilineString: MultilineString = {RAW_MULTI_LINE_STRING => MultilineString::RawMultiLineString(<>), MULTI_LINE_STRING_SQ_BEGIN_END => MultilineString::MultiLineStringSqBeginEnd(<>), MultilineStringMultiLineStringSqBeginMid => MultilineString::MultiLineStringSqBeginMid(<>), MULTI_LINE_STRING_DQ_BEGIN_END => MultilineString::MultiLineStringDqBeginEnd(<>), MultilineStringMultiLineStringDqBeginMid => MultilineString::MultiLineStringDqBeginMid(<>)};

pub StringInterpolationExpression: StringInterpolationExpression = {<interpolation_start_token:INTERPOLATION_START_TOKEN> <expression:Expression> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => StringInterpolationExpression{<>}};

pub StringInterpolation: StringInterpolation = {SIMPLE_STRING_INTERPOLATION => StringInterpolation::SimpleStringInterpolation(<>), StringInterpolationExpression => StringInterpolation::Expression(<>)};

pub SymbolLiteralOtherIdentifiers: SymbolLiteralOtherIdentifiers = {<period_token:PERIOD_TOKEN> <identifier:Identifier> => SymbolLiteralOtherIdentifiers{<>}};

pub SymbolLiteralValueIdentifier: SymbolLiteralValueIdentifier = {<identifier:Identifier> <symbol_literal_other_identifiers:(SymbolLiteralOtherIdentifiers)*> => SymbolLiteralValueIdentifier{<>}};

pub SymbolLiteralValue: SymbolLiteralValue = {SymbolLiteralValueIdentifier => SymbolLiteralValue::Identifier(<>), Operator => SymbolLiteralValue::Operator(<>), VOID_TOKEN => SymbolLiteralValue::Void(<>)};

pub SymbolLiteral: SymbolLiteral = {<hash_token:HASH_TOKEN> <symbol_literal_value:SymbolLiteralValue> => SymbolLiteral{<>}};

pub ListLiteral: ListLiteral = {<const_token:(CONST_TOKEN)?> <type_arguments:(TypeArguments)?> <open_square_bracket_token:OPEN_SQUARE_BRACKET_TOKEN> <elements:(Elements)?> <close_square_bracket_token:CLOSE_SQUARE_BRACKET_TOKEN> => ListLiteral{<>}};

pub SetOrMapLiteral: SetOrMapLiteral = {<const_token:(CONST_TOKEN)?> <type_arguments:(TypeArguments)?> <open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <elements:(Elements)?> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => SetOrMapLiteral{<>}};

pub ElementItem: ElementItem = {<comma_token:COMMA_TOKEN> <element:Element> => ElementItem{<>}};

pub Elements: Elements = {<element:Element> <element_item:(ElementItem)*> <comma_token:(COMMA_TOKEN)?> => Elements{<>}};

pub Element: Element = {ExpressionElement => Element::ExpressionElement(<>), MapElement => Element::MapElement(<>), SpreadElement => Element::SpreadElement(<>), IfElement => Element::IfElement(<>), ForElement => Element::ForElement(<>)};

pub ExpressionElement: ExpressionElement = {Expression};

pub MapElement: MapElement = {<expression:Expression> <colon_token:COLON_TOKEN> <expression2:Expression> => MapElement{<>}};

pub SpreadElementType: SpreadElementType = {POINTS_EXPAND_TOKEN => SpreadElementType::PointsExpand(<>), POINTS_EXPAND_QUESTION_TOKEN => SpreadElementType::PointsExpandQuestion(<>)};

pub SpreadElement: SpreadElement = {<spread_element_type:SpreadElementType> <expression:Expression> => SpreadElement{<>}};

pub ElementElse: ElementElse = {<else_token:ELSE_TOKEN> <element:Element> => ElementElse{<>}};

pub IfElement: IfElement = {<if_token:IF_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <expression:Expression> <close_paren_token:CLOSE_PAREN_TOKEN> <element:Element> <element_else:(ElementElse)?> => IfElement{<>}};

pub ForElement: ForElement = {<await_token:(AWAIT_TOKEN)?> <for_token:FOR_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <for_loop_parts:ForLoopParts> <close_paren_token:CLOSE_PAREN_TOKEN> <element:Element> => ForElement{<>}};

pub ConstructorTearoff: ConstructorTearoff = {<type_name:TypeName> <type_arguments:(TypeArguments)?> <period_token:PERIOD_TOKEN> <new_token:NEW_TOKEN> => ConstructorTearoff{<>}};

pub ThrowExpression: ThrowExpression = {<throw_token:THROW_TOKEN> <expression:Expression> => ThrowExpression{<>}};

pub ThrowExpressionWithoutCascade: ThrowExpressionWithoutCascade = {<throw_token:THROW_TOKEN> <expression_without_cascade:ExpressionWithoutCascade> => ThrowExpressionWithoutCascade{<>}};

pub FunctionExpression: FunctionExpression = {<formal_parameter_part:FormalParameterPart> <function_expression_body:FunctionExpressionBody> => FunctionExpression{<>}};

pub FunctionExpressionBodyArrowToken: FunctionExpressionBodyArrowToken = {<async_token:(ASYNC_TOKEN)?> <arrow_token:ARROW_TOKEN> <expression:Expression> => FunctionExpressionBodyArrowToken{<>}};

pub FunctionExpressionGeneratorAsyncToken: FunctionExpressionGeneratorAsyncToken = {<async_token:ASYNC_TOKEN> <asterisk_token:(ASTERISK_TOKEN)?> => FunctionExpressionGeneratorAsyncToken{<>}};

pub FunctionExpressionGeneratorSyncToken: FunctionExpressionGeneratorSyncToken = {<sync_token:SYNC_TOKEN> <asterisk_token:ASTERISK_TOKEN> => FunctionExpressionGeneratorSyncToken{<>}};

pub FunctionExpressionGenerator: FunctionExpressionGenerator = {FunctionExpressionGeneratorAsyncToken => FunctionExpressionGenerator::Async(<>), FunctionExpressionGeneratorSyncToken => FunctionExpressionGenerator::Sync(<>)};

pub FunctionExpressionBodyBlock: FunctionExpressionBodyBlock = {<function_expression_generator:(FunctionExpressionGenerator)?> <block:Block> => FunctionExpressionBodyBlock{<>}};

pub FunctionExpressionBody: FunctionExpressionBody = {FunctionExpressionBodyArrowToken => FunctionExpressionBody::Arrow(<>), FunctionExpressionBodyBlock => FunctionExpressionBody::Block(<>)};

pub ThisExpression: ThisExpression = {THIS_TOKEN};

pub NewExpression: NewExpression = {<new_token:NEW_TOKEN> <constructor_designation:ConstructorDesignation> <arguments:Arguments> => NewExpression{<>}};

pub ConstObjectExpression: ConstObjectExpression = {<const_token:CONST_TOKEN> <constructor_designation:ConstructorDesignation> <arguments:Arguments> => ConstObjectExpression{<>}};

pub ArgumentsArgumentList: ArgumentsArgumentList = {<argument_list:ArgumentList> <comma_token:(COMMA_TOKEN)?> => ArgumentsArgumentList{<>}};

pub Arguments: Arguments = {<open_paren_token:OPEN_PAREN_TOKEN> <argument_list:(ArgumentsArgumentList)?> <close_paren_token:CLOSE_PAREN_TOKEN> => Arguments{<>}};

pub ArgumentItem: ArgumentItem = {<comma_token:COMMA_TOKEN> <argument:Argument> => ArgumentItem{<>}};

pub ArgumentList: ArgumentList = {<argument:Argument> <argument_item:(ArgumentItem)*> => ArgumentList{<>}};

pub Argument: Argument = {<label:(Label)?> <expression:Expression> => Argument{<>}};

pub CascadeRight: CascadeRight = {<points_id_token:POINTS_ID_TOKEN> <cascade_section:CascadeSection> <cascade_right:(CascadeRight)?> => CascadeRight{<>}};

pub CascadePrefixType: CascadePrefixType = {POINTS_ID_QUESTION_TOKEN => CascadePrefixType::PointsIdQuestion(<>), POINTS_ID_TOKEN => CascadePrefixType::PointsId(<>)};

pub CascadeLeft: CascadeLeft = {<conditional_expression:ConditionalExpression> <cascade_prefix_type:CascadePrefixType> <cascade_section:CascadeSection> => CascadeLeft{<>}};

pub Cascade: Cascade = {<cascade_left:CascadeLeft> <cascade_right:(CascadeRight)?> => Cascade{<>}};

pub CascadeSection: CascadeSection = {<cascade_selector:CascadeSelector> <cascade_section_tail:CascadeSectionTail> => CascadeSection{<>}};

pub CascadeSelectorExpression: CascadeSelectorExpression = {<open_square_bracket_token:OPEN_SQUARE_BRACKET_TOKEN> <expression:Expression> <close_square_bracket_token:CLOSE_SQUARE_BRACKET_TOKEN> => CascadeSelectorExpression{<>}};

pub CascadeSelector: CascadeSelector = {CascadeSelectorExpression => CascadeSelector::Expression(<>), Identifier => CascadeSelector::Identifier(<>)};

pub SelectedCascadeAssignment: SelectedCascadeAssignment = {<assignable_selector:AssignableSelector> <cascade_assignment:CascadeAssignment> => SelectedCascadeAssignment{<>}};

pub SelectedCascade: SelectedCascade = {<selector:(Selector)*> <assignment:(SelectedCascadeAssignment)?> => SelectedCascade{<>}};

pub CascadeSectionTail: CascadeSectionTail = {CascadeAssignment => CascadeSectionTail::CascadeAssignment(<>), SelectedCascade => CascadeSectionTail::SelectedCascade(<>)};

pub CascadeAssignment: CascadeAssignment = {<assignment_operator:AssignmentOperator> <expression_without_cascade:ExpressionWithoutCascade> => CascadeAssignment{<>}};

pub AssignmentOperator: AssignmentOperator = {EQUAL_TOKEN => AssignmentOperator::Equal(<>), CompoundAssignmentOperator => AssignmentOperator::CompoundAssignmentOperator(<>)};

pub CompoundAssignmentOperator: CompoundAssignmentOperator = {TIMES_EQUAL_TOKEN => CompoundAssignmentOperator::TimesEqual(<>), DIV_EQUAL_TOKEN => CompoundAssignmentOperator::DivEqual(<>), INTEGER_DIV_EQUAL_TOKEN => CompoundAssignmentOperator::IntegerDivEqual(<>), MODULE_EQUAL_TOKEN => CompoundAssignmentOperator::ModuleEqual(<>), PLUS_EQUAL_TOKEN => CompoundAssignmentOperator::PlusEqual(<>), MINUS_EQUAL_TOKEN => CompoundAssignmentOperator::MinusEqual(<>), BIT_LEFT_EQUAL_TOKEN => CompoundAssignmentOperator::BitLeftEqual(<>), BIT_RIGHT0_EQUAL_TOKEN => CompoundAssignmentOperator::BitRight0Equal(<>), BIT_RIGHT_EQUAL_TOKEN => CompoundAssignmentOperator::BitRightEqual(<>), BIT_AND_EUQAL_TOKEN => CompoundAssignmentOperator::BitAndEuqal(<>), BIT_NEG_EQUAL_TOKEN => CompoundAssignmentOperator::BitNegEqual(<>), BIT_XOR_EQUAL_TOKEN => CompoundAssignmentOperator::BitXorEqual(<>), QUESTION_QUESTION_EQUAL_TOKEN => CompoundAssignmentOperator::QuestionQuestionEqual(<>)};

pub ConditionalExpressionExpressionWithoutCascade: ConditionalExpressionExpressionWithoutCascade = {<question_token:QUESTION_TOKEN> <expression_without_cascade:ExpressionWithoutCascade> <colon_token:COLON_TOKEN> <expression_without_cascade2:ExpressionWithoutCascade> => ConditionalExpressionExpressionWithoutCascade{<>}};

pub ConditionalExpression: ConditionalExpression = {<if_null_expression:IfNullExpression> <expression_without_cascade:(ConditionalExpressionExpressionWithoutCascade)?> => ConditionalExpression{<>}};

pub LogicalOrExpressionQuestionQuestion: LogicalOrExpressionQuestionQuestion = {<question_question_token:QUESTION_QUESTION_TOKEN> <logical_or_expression:LogicalOrExpression> => LogicalOrExpressionQuestionQuestion{<>}};

pub IfNullExpression: IfNullExpression = {<logical_or_expression:LogicalOrExpression> <logical_or_expression_question_question:(LogicalOrExpressionQuestionQuestion)*> => IfNullExpression{<>}};

pub LogicalAndExpressionOr: LogicalAndExpressionOr = {<or_token:OR_TOKEN> <logical_and_expression:LogicalAndExpression> => LogicalAndExpressionOr{<>}};

pub LogicalOrExpression: LogicalOrExpression = {<logical_and_expression:LogicalAndExpression> <logical_and_expression_or:(LogicalAndExpressionOr)*> => LogicalOrExpression{<>}};

pub EqualityExpressionAnd: EqualityExpressionAnd = {<and_token:AND_TOKEN> <equality_expression:EqualityExpression> => EqualityExpressionAnd{<>}};

pub LogicalAndExpression: LogicalAndExpression = {<equality_expression:EqualityExpression> <equality_expression_and:(EqualityExpressionAnd)*> => LogicalAndExpression{<>}};

pub EqualityExpressionInner: EqualityExpressionInner = {<equality_operator:EqualityOperator> <relational_expression:RelationalExpression> => EqualityExpressionInner{<>}};

pub EqualityExpressionRelationalExpression: EqualityExpressionRelationalExpression = {<relational_expression:RelationalExpression> <equality_expression_inner:(EqualityExpressionInner)?> => EqualityExpressionRelationalExpression{<>}};

pub EqualityExpressionEqualityOperator: EqualityExpressionEqualityOperator = {<super_token:SUPER_TOKEN> <equality_operator:EqualityOperator> <relational_expression:RelationalExpression> => EqualityExpressionEqualityOperator{<>}};

pub EqualityExpression: EqualityExpression = {EqualityExpressionRelationalExpression => EqualityExpression::RelationalExpression(<>), EqualityExpressionEqualityOperator => EqualityExpression::EqualityOperator(<>)};

pub EqualityOperator: EqualityOperator = {DOUBLE_EQUAL_TOKEN => EqualityOperator::DoubleEqual(<>), NOT_EQUAL_TOKEN => EqualityOperator::NotEqual(<>)};

pub BitwiseOrExpressionInterRelationalOperator: BitwiseOrExpressionInterRelationalOperator = {<relational_operator:RelationalOperator> <bitwise_or_expression:BitwiseOrExpression> => BitwiseOrExpressionInterRelationalOperator{<>}};

pub BitwiseOrExpressionInter: BitwiseOrExpressionInter = {TypeTest => BitwiseOrExpressionInter::TypeTest(<>), TypeCast => BitwiseOrExpressionInter::TypeCast(<>), BitwiseOrExpressionInterRelationalOperator => BitwiseOrExpressionInter::RelationalOperator(<>)};

pub RelationalExpressionBitwiseOrExpression: RelationalExpressionBitwiseOrExpression = {<bitwise_or_expression:BitwiseOrExpression> <bitwise_or_expression_inter:(BitwiseOrExpressionInter)?> => RelationalExpressionBitwiseOrExpression{<>}};

pub RelationalExpressionRelationalOperator: RelationalExpressionRelationalOperator = {<super_token:SUPER_TOKEN> <relational_operator:RelationalOperator> <bitwise_or_expression:BitwiseOrExpression> => RelationalExpressionRelationalOperator{<>}};

pub RelationalExpression: RelationalExpression = {RelationalExpressionBitwiseOrExpression => RelationalExpression::BitwiseOrExpression(<>), RelationalExpressionRelationalOperator => RelationalExpression::RelationalOperator(<>)};

pub RelationalOperator: RelationalOperator = {MORE_OR_EQUAL_TOKEN => RelationalOperator::MoreOrEqual(<>), MORE_TOKEN => RelationalOperator::More(<>), LESS_OR_EQUAL_TOKEN => RelationalOperator::LessOrEqual(<>), LESS_TOKEN => RelationalOperator::Less(<>)};

pub BitwiseXorExpressionBitXor: BitwiseXorExpressionBitXor = {<bit_xor_token:BIT_XOR_TOKEN> <bitwise_xor_expression:BitwiseXorExpression> => BitwiseXorExpressionBitXor{<>}};

pub BitwiseOrExpressionBitwiseXorExpression: BitwiseOrExpressionBitwiseXorExpression = {<bitwise_xor_expression:BitwiseXorExpression> <bitwise_xor_expression_bit_xor:(BitwiseXorExpressionBitXor)*> => BitwiseOrExpressionBitwiseXorExpression{<>}};

pub BitwiseXorExpressionBitXor: BitwiseXorExpressionBitXor = {<bit_xor_token:BIT_XOR_TOKEN> <bitwise_xor_expression:BitwiseXorExpression> => BitwiseXorExpressionBitXor{<>}};

pub BitwiseOrExpressionSuperToken: BitwiseOrExpressionSuperToken = {<super_token:SUPER_TOKEN> <bitwise_xor_expression_bit_xor:(BitwiseXorExpressionBitXor)+> => BitwiseOrExpressionSuperToken{<>}};

pub BitwiseOrExpression: BitwiseOrExpression = {BitwiseOrExpressionBitwiseXorExpression => BitwiseOrExpression::BitwiseXorExpression(<>), BitwiseOrExpressionSuperToken => BitwiseOrExpression::Super(<>)};

pub BitwiseAndExpressionBitNeg: BitwiseAndExpressionBitNeg = {<bit_neg_token:BIT_NEG_TOKEN> <bitwise_and_expression:BitwiseAndExpression> => BitwiseAndExpressionBitNeg{<>}};

pub BitwiseXorExpressionBitwiseAndExpression: BitwiseXorExpressionBitwiseAndExpression = {<bitwise_and_expression:BitwiseAndExpression> <bitwise_and_expression_bit_neg:(BitwiseAndExpressionBitNeg)*> => BitwiseXorExpressionBitwiseAndExpression{<>}};

pub BitwiseAndExpressionBitNeg: BitwiseAndExpressionBitNeg = {<bit_neg_token:BIT_NEG_TOKEN> <bitwise_and_expression:BitwiseAndExpression> => BitwiseAndExpressionBitNeg{<>}};

pub BitwiseXorExpressionSuperToken: BitwiseXorExpressionSuperToken = {<super_token:SUPER_TOKEN> <bitwise_and_expression_bit_neg:(BitwiseAndExpressionBitNeg)+> => BitwiseXorExpressionSuperToken{<>}};

pub BitwiseXorExpression: BitwiseXorExpression = {BitwiseXorExpressionBitwiseAndExpression => BitwiseXorExpression::BitwiseAndExpression(<>), BitwiseXorExpressionSuperToken => BitwiseXorExpression::Super(<>)};

pub ShiftExpressionBitAnd: ShiftExpressionBitAnd = {<bit_and_token:BIT_AND_TOKEN> <shift_expression:ShiftExpression> => ShiftExpressionBitAnd{<>}};

pub BitwiseAndExpressionShiftExpression: BitwiseAndExpressionShiftExpression = {<shift_expression:ShiftExpression> <shift_expression_bit_and:(ShiftExpressionBitAnd)*> => BitwiseAndExpressionShiftExpression{<>}};

pub ShiftExpressionBitAnd: ShiftExpressionBitAnd = {<bit_and_token:BIT_AND_TOKEN> <shift_expression:ShiftExpression> => ShiftExpressionBitAnd{<>}};

pub BitwiseAndExpressionSuperToken: BitwiseAndExpressionSuperToken = {<super_token:SUPER_TOKEN> <shift_expression_bit_and:(ShiftExpressionBitAnd)+> => BitwiseAndExpressionSuperToken{<>}};

pub BitwiseAndExpression: BitwiseAndExpression = {BitwiseAndExpressionShiftExpression => BitwiseAndExpression::ShiftExpression(<>), BitwiseAndExpressionSuperToken => BitwiseAndExpression::Super(<>)};

pub BitwiseOperator: BitwiseOperator = {BIT_AND_TOKEN => BitwiseOperator::BitAnd(<>), BIT_NEG_TOKEN => BitwiseOperator::BitNeg(<>), BIT_XOR_TOKEN => BitwiseOperator::BitXor(<>)};

pub ShiftExpressionInner: ShiftExpressionInner = {<shift_operator:ShiftOperator> <additive_expression:AdditiveExpression> => ShiftExpressionInner{<>}};

pub ShiftExpressionAdditiveExpression: ShiftExpressionAdditiveExpression = {<additive_expression:AdditiveExpression> <shift_expression_inner:(ShiftExpressionInner)*> => ShiftExpressionAdditiveExpression{<>}};

pub ShiftExpressionInner: ShiftExpressionInner = {<shift_operator:ShiftOperator> <additive_expression:AdditiveExpression> => ShiftExpressionInner{<>}};

pub ShiftExpressionSuperToken: ShiftExpressionSuperToken = {<super_token:SUPER_TOKEN> <shift_expression_inner:(ShiftExpressionInner)+> => ShiftExpressionSuperToken{<>}};

pub ShiftExpression: ShiftExpression = {ShiftExpressionAdditiveExpression => ShiftExpression::AdditiveExpression(<>), ShiftExpressionSuperToken => ShiftExpression::Super(<>)};

pub ShiftOperator: ShiftOperator = {BIT_LEFT_TOKEN => ShiftOperator::BitLeft(<>), BIT_RIGHT0_TOKEN => ShiftOperator::BitRight0(<>), BIT_RIGHT_TOKEN => ShiftOperator::BitRight(<>)};

pub AdditiveExpressionInner: AdditiveExpressionInner = {<additive_operator:AdditiveOperator> <multiplicative_expression:MultiplicativeExpression> => AdditiveExpressionInner{<>}};

pub AdditiveExpressionMultiplicativeExpression: AdditiveExpressionMultiplicativeExpression = {<multiplicative_expression:MultiplicativeExpression> <additive_expression_inner:(AdditiveExpressionInner)*> => AdditiveExpressionMultiplicativeExpression{<>}};

pub AdditiveExpressionInner: AdditiveExpressionInner = {<additive_operator:AdditiveOperator> <multiplicative_expression:MultiplicativeExpression> => AdditiveExpressionInner{<>}};

pub AdditiveExpressionSuperToken: AdditiveExpressionSuperToken = {<super_token:SUPER_TOKEN> <additive_expression_inner:(AdditiveExpressionInner)+> => AdditiveExpressionSuperToken{<>}};

pub AdditiveExpression: AdditiveExpression = {AdditiveExpressionMultiplicativeExpression => AdditiveExpression::MultiplicativeExpression(<>), AdditiveExpressionSuperToken => AdditiveExpression::Super(<>)};

pub AdditiveOperator: AdditiveOperator = {PLUS_TOKEN => AdditiveOperator::Plus(<>), MINUS_TOKEN => AdditiveOperator::Minus(<>)};

pub MultiplicativeExpressionInner: MultiplicativeExpressionInner = {<multiplicative_operator:MultiplicativeOperator> <unary_expression:UnaryExpression> => MultiplicativeExpressionInner{<>}};

pub MultiplicativeExpressionUnaryExpression: MultiplicativeExpressionUnaryExpression = {<unary_expression:UnaryExpression> <multiplicative_expression_inner:(MultiplicativeExpressionInner)*> => MultiplicativeExpressionUnaryExpression{<>}};

pub MultiplicativeExpressionInner: MultiplicativeExpressionInner = {<multiplicative_operator:MultiplicativeOperator> <unary_expression:UnaryExpression> => MultiplicativeExpressionInner{<>}};

pub MultiplicativeExpressionSuperToken: MultiplicativeExpressionSuperToken = {<super_token:SUPER_TOKEN> <multiplicative_expression_inner:(MultiplicativeExpressionInner)+> => MultiplicativeExpressionSuperToken{<>}};

pub MultiplicativeExpression: MultiplicativeExpression = {MultiplicativeExpressionUnaryExpression => MultiplicativeExpression::UnaryExpression(<>), MultiplicativeExpressionSuperToken => MultiplicativeExpression::Super(<>)};

pub MultiplicativeOperator: MultiplicativeOperator = {ASTERISK_TOKEN => MultiplicativeOperator::Asterisk(<>), DIVIDE_TOKEN => MultiplicativeOperator::Divide(<>), MODULUS_TOKEN => MultiplicativeOperator::Modulus(<>), INTEGER_DIV_TOKEN => MultiplicativeOperator::IntegerDiv(<>)};

pub UnaryExpressionPrefixOperator: UnaryExpressionPrefixOperator = {<prefix_operator:PrefixOperator> <unary_expression:UnaryExpression> => UnaryExpressionPrefixOperator{<>}};

pub UnaryOperator: UnaryOperator = {MinusOperator => UnaryOperator::MinusOperator(<>), TildeOperator => UnaryOperator::TildeOperator(<>)};

pub UnaryExpressionSuperToken: UnaryExpressionSuperToken = {<unary_operator:UnaryOperator> <super_token:SUPER_TOKEN> => UnaryExpressionSuperToken{<>}};

pub UnaryExpressionIncrementOperator: UnaryExpressionIncrementOperator = {<increment_operator:IncrementOperator> <assignable_expression:AssignableExpression> => UnaryExpressionIncrementOperator{<>}};

pub UnaryExpression: UnaryExpression = {UnaryExpressionPrefixOperator => UnaryExpression::PrefixOperator(<>), AwaitExpression => UnaryExpression::AwaitExpression(<>), PostfixExpression => UnaryExpression::PostfixExpression(<>), UnaryExpressionSuperToken => UnaryExpression::Super(<>), UnaryExpressionIncrementOperator => UnaryExpression::IncrementOperator(<>)};

pub PrefixOperator: PrefixOperator = {MinusOperator => PrefixOperator::MinusOperator(<>), NegationOperator => PrefixOperator::NegationOperator(<>), TildeOperator => PrefixOperator::TildeOperator(<>)};

pub MinusOperator: MinusOperator = {MINUS_TOKEN};

pub NegationOperator: NegationOperator = {EXCLAMATION_TOKEN};

pub TildeOperator: TildeOperator = {TILDE_TOKEN};

pub AwaitExpression: AwaitExpression = {<await_token:AWAIT_TOKEN> <unary_expression:UnaryExpression> => AwaitExpression{<>}};

pub PostfixExpressionAssignableExpression: PostfixExpressionAssignableExpression = {<assignable_expression:AssignableExpression> <postfix_operator:PostfixOperator> => PostfixExpressionAssignableExpression{<>}};

pub PostfixExpressionPrimary: PostfixExpressionPrimary = {<primary:Primary> <selector:(Selector)*> => PostfixExpressionPrimary{<>}};

pub PostfixExpression: PostfixExpression = {PostfixExpressionAssignableExpression => PostfixExpression::AssignableExpression(<>), PostfixExpressionPrimary => PostfixExpression::Primary(<>)};

pub PostfixOperator: PostfixOperator = {IncrementOperator};

pub ConstructorInvocationTypeName: ConstructorInvocationTypeName = {<type_name:TypeName> <type_arguments:TypeArguments> <period_token:PERIOD_TOKEN> <new_token:NEW_TOKEN> <arguments:Arguments> => ConstructorInvocationTypeName{<>}};

pub ConstructorInvocationPeriodToken: ConstructorInvocationPeriodToken = {<type_name:TypeName> <period_token:PERIOD_TOKEN> <new_token:NEW_TOKEN> <arguments:Arguments> => ConstructorInvocationPeriodToken{<>}};

pub ConstructorInvocation: ConstructorInvocation = {ConstructorInvocationTypeName => ConstructorInvocation::TypeName(<>), ConstructorInvocationPeriodToken => ConstructorInvocation::Period(<>)};

pub Selector: Selector = {EXCLAMATION_TOKEN => Selector::Exclamation(<>), AssignableSelector => Selector::AssignableSelector(<>), ArgumentPart => Selector::ArgumentPart(<>), TypeArguments => Selector::TypeArguments(<>)};

pub ArgumentPart: ArgumentPart = {<type_arguments:(TypeArguments)?> <arguments:Arguments> => ArgumentPart{<>}};

pub IncrementOperator: IncrementOperator = {PLUS_PLUS_TOKEN => IncrementOperator::PlusPlus(<>), MINUS_MINUS_TOKEN => IncrementOperator::MinusMinus(<>)};

pub AssignableExpressionPrimary: AssignableExpressionPrimary = {<primary:Primary> <assignable_selector_part:AssignableSelectorPart> => AssignableExpressionPrimary{<>}};

pub AssignableExpressionUnconditionalAssignableSelector: AssignableExpressionUnconditionalAssignableSelector = {<super_token:SUPER_TOKEN> <unconditional_assignable_selector:UnconditionalAssignableSelector> => AssignableExpressionUnconditionalAssignableSelector{<>}};

pub AssignableExpression: AssignableExpression = {AssignableExpressionPrimary => AssignableExpression::Primary(<>), AssignableExpressionUnconditionalAssignableSelector => AssignableExpression::UnconditionalAssignableSelector(<>), Identifier => AssignableExpression::Identifier(<>)};

pub AssignableSelectorPart: AssignableSelectorPart = {<selector:(Selector)*> <assignable_selector:AssignableSelector> => AssignableSelectorPart{<>}};

pub UnconditionalAssignableSelectorExpression: UnconditionalAssignableSelectorExpression = {<open_square_bracket_token:OPEN_SQUARE_BRACKET_TOKEN> <expression:Expression> <close_square_bracket_token:CLOSE_SQUARE_BRACKET_TOKEN> => UnconditionalAssignableSelectorExpression{<>}};

pub UnconditionalAssignableSelectorIdentifier: UnconditionalAssignableSelectorIdentifier = {<period_token:PERIOD_TOKEN> <identifier:Identifier> => UnconditionalAssignableSelectorIdentifier{<>}};

pub UnconditionalAssignableSelector: UnconditionalAssignableSelector = {UnconditionalAssignableSelectorExpression => UnconditionalAssignableSelector::Expression(<>), UnconditionalAssignableSelectorIdentifier => UnconditionalAssignableSelector::Identifier(<>)};

pub AssignableSelectorIdentifier: AssignableSelectorIdentifier = {<question_id_token:QUESTION_ID_TOKEN> <identifier:Identifier> => AssignableSelectorIdentifier{<>}};

pub AssignableSelectorQuestionToken: AssignableSelectorQuestionToken = {<question_token:QUESTION_TOKEN> <open_square_bracket_token:OPEN_SQUARE_BRACKET_TOKEN> <expression:Expression> <close_square_bracket_token:CLOSE_SQUARE_BRACKET_TOKEN> => AssignableSelectorQuestionToken{<>}};

pub AssignableSelector: AssignableSelector = {UnconditionalAssignableSelector => AssignableSelector::UnconditionalAssignableSelector(<>), AssignableSelectorIdentifier => AssignableSelector::Identifier(<>), AssignableSelectorQuestionToken => AssignableSelector::Question(<>)};

pub Identifier: Identifier = {IDENTIFIER => Identifier::Identifier(<>), BUILT_IN_IDENTIFIER => Identifier::BuiltInIdentifier(<>), OTHER_IDENTIFIER => Identifier::OtherIdentifier(<>)};

pub TypeIdentifier: TypeIdentifier = {IDENTIFIER => TypeIdentifier::Identifier(<>), OTHER_IDENTIFIER => TypeIdentifier::OtherIdentifier(<>), DYNAMIC_TOKEN => TypeIdentifier::Dynamic(<>)};

pub IdentifierOrNew: IdentifierOrNew = {Identifier => IdentifierOrNew::Identifier(<>), NEW_TOKEN => IdentifierOrNew::New(<>)};

pub QualifiedNameSingle: QualifiedNameSingle = {<type_identifier:TypeIdentifier> <period_token:PERIOD_TOKEN> <identifier_or_new:IdentifierOrNew> => QualifiedNameSingle{<>}};

pub QualifiedNameDouble: QualifiedNameDouble = {<type_identifier:TypeIdentifier> <period_token:PERIOD_TOKEN> <type_identifier2:TypeIdentifier> <period_token2:PERIOD_TOKEN> <identifier_or_new:IdentifierOrNew> => QualifiedNameDouble{<>}};

pub QualifiedName: QualifiedName = {QualifiedNameSingle => QualifiedName::QualifiedNameSingle(<>), QualifiedNameDouble => QualifiedName::QualifiedNameDouble(<>)};

pub TypeTest: TypeTest = {<is_operator:IsOperator> <type_not_void:TypeNotVoid> => TypeTest{<>}};

pub IsOperator: IsOperator = {<is_token:IS_TOKEN> <exclamation_token:(EXCLAMATION_TOKEN)?> => IsOperator{<>}};

pub TypeCast: TypeCast = {<as_operator:AsOperator> <type_not_void:TypeNotVoid> => TypeCast{<>}};

pub AsOperator: AsOperator = {AS_TOKEN};

pub Statements: Statements = {(Statement)* => Statements(<>)};

pub Statement: Statement = {<label:(Label)*> <non_labelled_statement:NonLabelledStatement> => Statement{<>}};

pub NonLabelledStatement: NonLabelledStatement = {Block => NonLabelledStatement::Block(<>), LocalVariableDeclaration => NonLabelledStatement::LocalVariableDeclaration(<>), ForStatement => NonLabelledStatement::ForStatement(<>), WhileStatement => NonLabelledStatement::WhileStatement(<>), DoStatement => NonLabelledStatement::DoStatement(<>), SwitchStatement => NonLabelledStatement::SwitchStatement(<>), IfStatement => NonLabelledStatement::IfStatement(<>), RethrowStatement => NonLabelledStatement::RethrowStatement(<>), TryStatement => NonLabelledStatement::TryStatement(<>), BreakStatement => NonLabelledStatement::BreakStatement(<>), ContinueStatement => NonLabelledStatement::ContinueStatement(<>), ReturnStatement => NonLabelledStatement::ReturnStatement(<>), YieldStatement => NonLabelledStatement::YieldStatement(<>), YieldEachStatement => NonLabelledStatement::YieldEachStatement(<>), ExpressionStatement => NonLabelledStatement::ExpressionStatement(<>), AssertStatement => NonLabelledStatement::AssertStatement(<>), LocalFunctionDeclaration => NonLabelledStatement::LocalFunctionDeclaration(<>)};

pub ExpressionStatement: ExpressionStatement = {<expression:(Expression)?> <semicolon_token:SEMICOLON_TOKEN> => ExpressionStatement{<>}};

pub LocalVariableDeclaration: LocalVariableDeclaration = {<metadata:Metadata> <initialized_variable_declaration:InitializedVariableDeclaration> <semicolon_token:SEMICOLON_TOKEN> => LocalVariableDeclaration{<>}};

pub LocalFunctionDeclaration: LocalFunctionDeclaration = {<metadata:Metadata> <function_signature:FunctionSignature> <function_body:FunctionBody> => LocalFunctionDeclaration{<>}};

pub StatementElse: StatementElse = {<else_token:ELSE_TOKEN> <statement:Statement> => StatementElse{<>}};

pub IfStatement: IfStatement = {<if_token:IF_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <expression:Expression> <close_paren_token:CLOSE_PAREN_TOKEN> <statement:Statement> <statement_else:(StatementElse)?> => IfStatement{<>}};

pub ForStatement: ForStatement = {<await_token:(AWAIT_TOKEN)?> <for_token:FOR_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <for_loop_parts:ForLoopParts> <close_paren_token:CLOSE_PAREN_TOKEN> <statement:Statement> => ForStatement{<>}};

pub ForLoopPartsSemicolonToken: ForLoopPartsSemicolonToken = {<for_initializer_statement:ForInitializerStatement> <expression:(Expression)?> <semicolon_token:SEMICOLON_TOKEN> <expression_list:(ExpressionList)?> => ForLoopPartsSemicolonToken{<>}};

pub ForLoopPartsMetadata: ForLoopPartsMetadata = {<metadata:Metadata> <declared_identifier:DeclaredIdentifier> <in_token:IN_TOKEN> <expression:Expression> => ForLoopPartsMetadata{<>}};

pub ForLoopPartsInToken: ForLoopPartsInToken = {<identifier:Identifier> <in_token:IN_TOKEN> <expression:Expression> => ForLoopPartsInToken{<>}};

pub ForLoopParts: ForLoopParts = {ForLoopPartsSemicolonToken => ForLoopParts::Semicolon(<>), ForLoopPartsMetadata => ForLoopParts::Metadata(<>), ForLoopPartsInToken => ForLoopParts::In(<>)};

pub ForInitializerStatementSemicolonToken: ForInitializerStatementSemicolonToken = {<expression:(Expression)?> <semicolon_token:SEMICOLON_TOKEN> => ForInitializerStatementSemicolonToken{<>}};

pub ForInitializerStatement: ForInitializerStatement = {LocalVariableDeclaration => ForInitializerStatement::LocalVariableDeclaration(<>), ForInitializerStatementSemicolonToken => ForInitializerStatement::Semicolon(<>)};

pub WhileStatement: WhileStatement = {<while_token:WHILE_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <expression:Expression> <close_paren_token:CLOSE_PAREN_TOKEN> <statement:Statement> => WhileStatement{<>}};

pub DoStatement: DoStatement = {<do_token:DO_TOKEN> <statement:Statement> <while_token:WHILE_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <expression:Expression> <close_paren_token:CLOSE_PAREN_TOKEN> <semicolon_token:SEMICOLON_TOKEN> => DoStatement{<>}};

pub SwitchStatement: SwitchStatement = {<switch_token:SWITCH_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <expression:Expression> <close_paren_token:CLOSE_PAREN_TOKEN> <open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <switch_case:(SwitchCase)*> <default_case:(DefaultCase)?> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => SwitchStatement{<>}};

pub SwitchCase: SwitchCase = {<label:(Label)*> <case_token:CASE_TOKEN> <expression:Expression> <colon_token:COLON_TOKEN> <statements:Statements> => SwitchCase{<>}};

pub DefaultCase: DefaultCase = {<label:(Label)*> <default_token:DEFAULT_TOKEN> <colon_token:COLON_TOKEN> <statements:Statements> => DefaultCase{<>}};

pub RethrowStatement: RethrowStatement = {<rethrow_token:RETHROW_TOKEN> <semicolon_token:SEMICOLON_TOKEN> => RethrowStatement{<>}};

pub TryStatementOnPart: TryStatementOnPart = {<on_part:(OnPart)+> <finally_part:(FinallyPart)?> => TryStatementOnPart{<>}};

pub TryStatementCatchFinally: TryStatementCatchFinally = {TryStatementOnPart => TryStatementCatchFinally::TryStatementOnPart(<>), FinallyPart => TryStatementCatchFinally::FinallyPart(<>)};

pub TryStatement: TryStatement = {<try_token:TRY_TOKEN> <block:Block> <try_statement_catch_finally:TryStatementCatchFinally> => TryStatement{<>}};

pub OnPartCatchPart: OnPartCatchPart = {<catch_part:CatchPart> <block:Block> => OnPartCatchPart{<>}};

pub OnPartTypeNotVoid: OnPartTypeNotVoid = {<on_token:ON_TOKEN> <type_not_void:TypeNotVoid> <catch_part:(CatchPart)?> <block:Block> => OnPartTypeNotVoid{<>}};

pub OnPart: OnPart = {OnPartCatchPart => OnPart::CatchPart(<>), OnPartTypeNotVoid => OnPart::TypeNotVoid(<>)};

pub IdentifierItem: IdentifierItem = {<comma_token:COMMA_TOKEN> <identifier:Identifier> => IdentifierItem{<>}};

pub CatchPart: CatchPart = {<catch_token:CATCH_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <identifier:Identifier> <identifier_item:(IdentifierItem)?> <close_paren_token:CLOSE_PAREN_TOKEN> => CatchPart{<>}};

pub FinallyPart: FinallyPart = {<finally_token:FINALLY_TOKEN> <block:Block> => FinallyPart{<>}};

pub ReturnStatement: ReturnStatement = {<return_token:RETURN_TOKEN> <expression:(Expression)?> <semicolon_token:SEMICOLON_TOKEN> => ReturnStatement{<>}};

pub Label: Label = {<identifier:Identifier> <colon_token:COLON_TOKEN> => Label{<>}};

pub BreakStatement: BreakStatement = {<break_token:BREAK_TOKEN> <identifier:(Identifier)?> <semicolon_token:SEMICOLON_TOKEN> => BreakStatement{<>}};

pub ContinueStatement: ContinueStatement = {<continue_token:CONTINUE_TOKEN> <identifier:(Identifier)?> <semicolon_token:SEMICOLON_TOKEN> => ContinueStatement{<>}};

pub YieldStatement: YieldStatement = {<yield_token:YIELD_TOKEN> <expression:Expression> <semicolon_token:SEMICOLON_TOKEN> => YieldStatement{<>}};

pub YieldEachStatement: YieldEachStatement = {<yield_token:YIELD_TOKEN> <asterisk_token:ASTERISK_TOKEN> <expression:Expression> <semicolon_token:SEMICOLON_TOKEN> => YieldEachStatement{<>}};

pub AssertStatement: AssertStatement = {<assertion:Assertion> <semicolon_token:SEMICOLON_TOKEN> => AssertStatement{<>}};

pub ExpressionItem: ExpressionItem = {<comma_token:COMMA_TOKEN> <expression:Expression> => ExpressionItem{<>}};

pub Assertion: Assertion = {<assert_token:ASSERT_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <expression:Expression> <expression_item:(ExpressionItem)?> <comma_token:(COMMA_TOKEN)?> <close_paren_token:CLOSE_PAREN_TOKEN> => Assertion{<>}};

pub ExternalFunctionSignature: ExternalFunctionSignature = {<external_token:EXTERNAL_TOKEN> <function_signature:FunctionSignature> <semicolon_token:SEMICOLON_TOKEN> => ExternalFunctionSignature{<>}};

pub ExternalGetterSignature: ExternalGetterSignature = {<external_token:EXTERNAL_TOKEN> <getter_signature:GetterSignature> <semicolon_token:SEMICOLON_TOKEN> => ExternalGetterSignature{<>}};

pub ExternalSetterSignature: ExternalSetterSignature = {<external_token:EXTERNAL_TOKEN> <setter_signature:SetterSignature> <semicolon_token:SEMICOLON_TOKEN> => ExternalSetterSignature{<>}};

pub TopLevelDeclarationFunctionSignature: TopLevelDeclarationFunctionSignature = {<function_signature:FunctionSignature> <function_body:FunctionBody> => TopLevelDeclarationFunctionSignature{<>}};

pub TopLevelDeclarationGetterSignature: TopLevelDeclarationGetterSignature = {<getter_signature:GetterSignature> <function_body:FunctionBody> => TopLevelDeclarationGetterSignature{<>}};

pub TopLevelDeclarationSetterSignature: TopLevelDeclarationSetterSignature = {<setter_signature:SetterSignature> <function_body:FunctionBody> => TopLevelDeclarationSetterSignature{<>}};

pub FinalTokenOrConstToken: FinalTokenOrConstToken = {FINAL_TOKEN => FinalTokenOrConstToken::Final(<>), CONST_TOKEN => FinalTokenOrConstToken::Const(<>)};

pub TopLevelDeclarationTopLevelStaticFinalDeclarations: TopLevelDeclarationTopLevelStaticFinalDeclarations = {<final_token_or_const_token:FinalTokenOrConstToken> <top_level_static_final_declarations:TopLevelStaticFinalDeclarations> <semicolon_token:SEMICOLON_TOKEN> => TopLevelDeclarationTopLevelStaticFinalDeclarations{<>}};

pub TopLevelDeclarationLateToken: TopLevelDeclarationLateToken = {<late_token:LATE_TOKEN> <final_token:FINAL_TOKEN> <dart_type:(Type)?> <initialized_identifier_list:InitializedIdentifierList> <semicolon_token:SEMICOLON_TOKEN> => TopLevelDeclarationLateToken{<>}};

pub TopLevelDeclarationVarOrType: TopLevelDeclarationVarOrType = {<late_token:(LATE_TOKEN)?> <var_or_type:VarOrType> <initialized_identifier_list:InitializedIdentifierList> <semicolon_token:SEMICOLON_TOKEN> => TopLevelDeclarationVarOrType{<>}};

pub TopLevelDeclaration: TopLevelDeclaration = {ClassDeclaration => TopLevelDeclaration::ClassDeclaration(<>), MixinDeclaration => TopLevelDeclaration::MixinDeclaration(<>), ExtensionDeclaration => TopLevelDeclaration::ExtensionDeclaration(<>), EnumType => TopLevelDeclaration::EnumType(<>), TypeAlias => TopLevelDeclaration::TypeAlias(<>), ExternalFunctionSignature => TopLevelDeclaration::ExternalFunctionSignature(<>), ExternalGetterSignature => TopLevelDeclaration::ExternalGetterSignature(<>), ExternalSetterSignature => TopLevelDeclaration::ExternalSetterSignature(<>), TopLevelDeclarationFunctionSignature => TopLevelDeclaration::FunctionSignature(<>), TopLevelDeclarationGetterSignature => TopLevelDeclaration::GetterSignature(<>), TopLevelDeclarationSetterSignature => TopLevelDeclaration::SetterSignature(<>), TopLevelDeclarationTopLevelStaticFinalDeclarations => TopLevelDeclaration::TopLevelStaticFinalDeclarations(<>), TopLevelDeclarationLateToken => TopLevelDeclaration::Late(<>), TopLevelDeclarationVarOrType => TopLevelDeclaration::VarOrType(<>)};

pub TypedStaticFinalDeclarations: TypedStaticFinalDeclarations = {<dart_type:Type> <static_final_declaration_list:StaticFinalDeclarationList> => TypedStaticFinalDeclarations{<>}};

pub TopLevelStaticFinalDeclarations: TopLevelStaticFinalDeclarations = {StaticFinalDeclarationList => TopLevelStaticFinalDeclarations::StaticFinalDeclarationList(<>), TypedStaticFinalDeclarations => TopLevelStaticFinalDeclarations::TypedStaticFinalDeclarations(<>)};

pub LibraryDeclarationMetadata: LibraryDeclarationMetadata = {<metadata:Metadata> <top_level_declaration:TopLevelDeclaration> => LibraryDeclarationMetadata{<>}};

pub LibraryDeclaration: LibraryDeclaration = {<script_tag:(ScriptTag)?> <library_name:(LibraryName)?> <import_or_export:(ImportOrExport)*> <part_directive:(PartDirective)*> <metadata:(LibraryDeclarationMetadata)*> <eof:EOF> => LibraryDeclaration{<>}};

pub ScriptTag: ScriptTag = {<hash_exclamation_token:HASH_EXCLAMATION_TOKEN> <script_tag_content:SCRIPT_TAG_CONTENT> <newline:NEWLINE> => ScriptTag{<>}};

pub LibraryName: LibraryName = {<metadata:Metadata> <library_token:LIBRARY_TOKEN> <dotted_identifier_list:DottedIdentifierList> <semicolon_token:SEMICOLON_TOKEN> => LibraryName{<>}};

pub ImportOrExport: ImportOrExport = {LibraryImport => ImportOrExport::LibraryImport(<>), LibraryExport => ImportOrExport::LibraryExport(<>)};

pub IdentifierSelector: IdentifierSelector = {<period_token:PERIOD_TOKEN> <identifier:Identifier> => IdentifierSelector{<>}};

pub DottedIdentifierList: DottedIdentifierList = {<identifier:Identifier> <identifier_selector:(IdentifierSelector)*> => DottedIdentifierList{<>}};

pub LibraryImport: LibraryImport = {<metadata:Metadata> <import_specification:ImportSpecification> => LibraryImport{<>}};

pub ImportSpecificationAsToken: ImportSpecificationAsToken = {<deferred_token:(DEFERRED_TOKEN)?> <as_token:AS_TOKEN> <identifier:Identifier> => ImportSpecificationAsToken{<>}};

pub ImportSpecification: ImportSpecification = {<import_token:IMPORT_TOKEN> <configurable_uri:ConfigurableUri> <as_token:(ImportSpecificationAsToken)?> <combinator:(Combinator)*> <semicolon_token:SEMICOLON_TOKEN> => ImportSpecification{<>}};

pub LibraryExport: LibraryExport = {<metadata:Metadata> <export_token:EXPORT_TOKEN> <configurable_uri:ConfigurableUri> <combinator:(Combinator)*> <semicolon_token:SEMICOLON_TOKEN> => LibraryExport{<>}};

pub ShowCombinator: ShowCombinator = {<show_token:SHOW_TOKEN> <identifier_list:IdentifierList> => ShowCombinator{<>}};

pub HideCombinator: HideCombinator = {<hide_token:HIDE_TOKEN> <identifier_list:IdentifierList> => HideCombinator{<>}};

pub Combinator: Combinator = {ShowCombinator => Combinator::ShowCombinator(<>), HideCombinator => Combinator::HideCombinator(<>)};

pub IdentifierItem: IdentifierItem = {<comma_token:COMMA_TOKEN> <identifier:Identifier> => IdentifierItem{<>}};

pub IdentifierList: IdentifierList = {<identifier:Identifier> <identifier_item:(IdentifierItem)*> => IdentifierList{<>}};

pub PartDirective: PartDirective = {<metadata:Metadata> <part_token:PART_TOKEN> <uri:Uri> <semicolon_token:SEMICOLON_TOKEN> => PartDirective{<>}};

pub DottedIdentifierListOrUri: DottedIdentifierListOrUri = {DottedIdentifierList => DottedIdentifierListOrUri::DottedIdentifierList(<>), Uri => DottedIdentifierListOrUri::Uri(<>)};

pub PartHeader: PartHeader = {<metadata:Metadata> <part_token:PART_TOKEN> <of_token:OF_TOKEN> <dotted_identifier_list_or_uri:DottedIdentifierListOrUri> <semicolon_token:SEMICOLON_TOKEN> => PartHeader{<>}};

pub PartDeclarationMetadata: PartDeclarationMetadata = {<metadata:Metadata> <top_level_declaration:TopLevelDeclaration> => PartDeclarationMetadata{<>}};

pub PartDeclaration: PartDeclaration = {<part_header:PartHeader> <metadata:(PartDeclarationMetadata)*> <eof:EOF> => PartDeclaration{<>}};

pub Uri: Uri = {StringLiteral};

pub ConfigurableUri: ConfigurableUri = {<uri:Uri> <configuration_uri:(ConfigurationUri)*> => ConfigurableUri{<>}};

pub ConfigurationUri: ConfigurationUri = {<if_token:IF_TOKEN> <open_paren_token:OPEN_PAREN_TOKEN> <uri_test:UriTest> <close_paren_token:CLOSE_PAREN_TOKEN> <uri:Uri> => ConfigurationUri{<>}};

pub StringLiteralDoubleEqual: StringLiteralDoubleEqual = {<double_equal_token:DOUBLE_EQUAL_TOKEN> <string_literal:StringLiteral> => StringLiteralDoubleEqual{<>}};

pub UriTest: UriTest = {<dotted_identifier_list:DottedIdentifierList> <string_literal_double_equal:(StringLiteralDoubleEqual)?> => UriTest{<>}};

pub TypeFunctionType: TypeFunctionType = {<function_type:FunctionType> <question_token:(QUESTION_TOKEN)?> => TypeFunctionType{<>}};

pub Type: Type = {TypeFunctionType => Type::FunctionType(<>), TypeNotFunction => Type::TypeNotFunction(<>)};

pub TypeNotVoidFunctionType: TypeNotVoidFunctionType = {<function_type:FunctionType> <question_token:(QUESTION_TOKEN)?> => TypeNotVoidFunctionType{<>}};

pub TypeNotVoid: TypeNotVoid = {TypeNotVoidFunctionType => TypeNotVoid::FunctionType(<>), TypeNotVoidNotFunction => TypeNotVoid::TypeNotVoidNotFunction(<>)};

pub TypeNotFunction: TypeNotFunction = {VOID_TOKEN => TypeNotFunction::Void(<>), TypeNotVoidNotFunction => TypeNotFunction::TypeNotVoidNotFunction(<>)};

pub TypeNotVoidNotFunctionTypeName: TypeNotVoidNotFunctionTypeName = {<type_name:TypeName> <type_arguments:(TypeArguments)?> <question_token:(QUESTION_TOKEN)?> => TypeNotVoidNotFunctionTypeName{<>}};

pub TypeNotVoidNotFunctionFunctionToken: TypeNotVoidNotFunctionFunctionToken = {<function_token:FUNCTION_TOKEN> <question_token:(QUESTION_TOKEN)?> => TypeNotVoidNotFunctionFunctionToken{<>}};

pub TypeNotVoidNotFunction: TypeNotVoidNotFunction = {TypeNotVoidNotFunctionTypeName => TypeNotVoidNotFunction::TypeName(<>), TypeNotVoidNotFunctionFunctionToken => TypeNotVoidNotFunction::Function(<>)};

pub TypeIdentifierSelector: TypeIdentifierSelector = {<period_token:PERIOD_TOKEN> <type_identifier:TypeIdentifier> => TypeIdentifierSelector{<>}};

pub TypeName: TypeName = {<type_identifier:TypeIdentifier> <type_identifier_selector:(TypeIdentifierSelector)?> => TypeName{<>}};

pub TypeArguments: TypeArguments = {<less_token:LESS_TOKEN> <type_list:TypeList> <more_token:MORE_TOKEN> => TypeArguments{<>}};

pub TypeItem: TypeItem = {<comma_token:COMMA_TOKEN> <dart_type:Type> => TypeItem{<>}};

pub TypeList: TypeList = {<dart_type:Type> <type_item:(TypeItem)*> => TypeList{<>}};

pub TypeNotVoidNotFunctionItem: TypeNotVoidNotFunctionItem = {<comma_token:COMMA_TOKEN> <type_not_void_not_function:TypeNotVoidNotFunction> => TypeNotVoidNotFunctionItem{<>}};

pub TypeNotVoidNotFunctionList: TypeNotVoidNotFunctionList = {<type_not_void_not_function:TypeNotVoidNotFunction> <type_not_void_not_function_item:(TypeNotVoidNotFunctionItem)*> => TypeNotVoidNotFunctionList{<>}};

pub FunctionTypeTypeNotFunction: FunctionTypeTypeNotFunction = {<type_not_function:TypeNotFunction> <function_type_tails:FunctionTypeTails> => FunctionTypeTypeNotFunction{<>}};

pub FunctionType: FunctionType = {FunctionTypeTails => FunctionType::FunctionTypeTails(<>), FunctionTypeTypeNotFunction => FunctionType::TypeNotFunction(<>)};

pub FunctionTypeTailsMany: FunctionTypeTailsMany = {<function_type_tail:FunctionTypeTail> <question_token:(QUESTION_TOKEN)?> <function_type_tails:FunctionTypeTails> => FunctionTypeTailsMany{<>}};

pub FunctionTypeTails: FunctionTypeTails = {FunctionTypeTailsMany => FunctionTypeTails::FunctionTypeTailsMany(<>), FunctionTypeTail => FunctionTypeTails::FunctionTypeTail(<>)};

pub FunctionTypeTail: FunctionTypeTail = {<function_token:FUNCTION_TOKEN> <type_parameters:(TypeParameters)?> <parameter_type_list:ParameterTypeList> => FunctionTypeTail{<>}};

pub EmptyParameters: EmptyParameters = {<open_paren_token:OPEN_PAREN_TOKEN> <close_paren_token:CLOSE_PAREN_TOKEN> => EmptyParameters{<>}};

pub NormalWithOptionalParameters: NormalWithOptionalParameters = {<open_paren_token:OPEN_PAREN_TOKEN> <normal_parameter_types:NormalParameterTypes> <comma_token:COMMA_TOKEN> <optional_parameter_types:OptionalParameterTypes> <close_paren_token:CLOSE_PAREN_TOKEN> => NormalWithOptionalParameters{<>}};

pub ParameterTypeListNormalParameterTypes: ParameterTypeListNormalParameterTypes = {<open_paren_token:OPEN_PAREN_TOKEN> <normal_parameter_types:NormalParameterTypes> <comma_token:(COMMA_TOKEN)?> <close_paren_token:CLOSE_PAREN_TOKEN> => ParameterTypeListNormalParameterTypes{<>}};

pub ParameterTypeListOptionalParameterTypes: ParameterTypeListOptionalParameterTypes = {<open_paren_token:OPEN_PAREN_TOKEN> <optional_parameter_types:OptionalParameterTypes> <close_paren_token:CLOSE_PAREN_TOKEN> => ParameterTypeListOptionalParameterTypes{<>}};

pub ParameterTypeList: ParameterTypeList = {EmptyParameters => ParameterTypeList::EmptyParameters(<>), NormalWithOptionalParameters => ParameterTypeList::NormalWithOptionalParameters(<>), ParameterTypeListNormalParameterTypes => ParameterTypeList::NormalParameterTypes(<>), ParameterTypeListOptionalParameterTypes => ParameterTypeList::OptionalParameterTypes(<>)};

pub NormalParameterTypeItem: NormalParameterTypeItem = {<comma_token:COMMA_TOKEN> <normal_parameter_type:NormalParameterType> => NormalParameterTypeItem{<>}};

pub NormalParameterTypes: NormalParameterTypes = {<normal_parameter_type:NormalParameterType> <normal_parameter_type_item:(NormalParameterTypeItem)*> => NormalParameterTypes{<>}};

pub IdentifierParameterType: IdentifierParameterType = {<metadata:Metadata> <typed_identifier:TypedIdentifier> => IdentifierParameterType{<>}};

pub TypeParameterType: TypeParameterType = {<metadata:Metadata> <dart_type:Type> => TypeParameterType{<>}};

pub NormalParameterType: NormalParameterType = {IdentifierParameterType => NormalParameterType::IdentifierParameterType(<>), TypeParameterType => NormalParameterType::TypeParameterType(<>)};

pub OptionalParameterTypes: OptionalParameterTypes = {OptionalPositionalParameterTypes => OptionalParameterTypes::OptionalPositionalParameterTypes(<>), NamedParameterTypes => OptionalParameterTypes::NamedParameterTypes(<>)};

pub OptionalPositionalParameterTypes: OptionalPositionalParameterTypes = {<open_square_bracket_token:OPEN_SQUARE_BRACKET_TOKEN> <normal_parameter_types:NormalParameterTypes> <comma_token:(COMMA_TOKEN)?> <close_square_bracket_token:CLOSE_SQUARE_BRACKET_TOKEN> => OptionalPositionalParameterTypes{<>}};

pub NamedParameterTypeItem: NamedParameterTypeItem = {<comma_token:COMMA_TOKEN> <named_parameter_type:NamedParameterType> => NamedParameterTypeItem{<>}};

pub NamedParameterTypes: NamedParameterTypes = {<open_curly_bracket_token:OPEN_CURLY_BRACKET_TOKEN> <named_parameter_type:NamedParameterType> <named_parameter_type_item:(NamedParameterTypeItem)*> <comma_token:(COMMA_TOKEN)?> <close_curly_bracket_token:CLOSE_CURLY_BRACKET_TOKEN> => NamedParameterTypes{<>}};

pub NamedParameterType: NamedParameterType = {<metadata:Metadata> <required_token:(REQUIRED_TOKEN)?> <typed_identifier:TypedIdentifier> => NamedParameterType{<>}};

pub TypedIdentifier: TypedIdentifier = {<dart_type:Type> <identifier:Identifier> => TypedIdentifier{<>}};

pub TypeAliasTypeIdentifier: TypeAliasTypeIdentifier = {<typedef_token:TYPEDEF_TOKEN> <type_identifier:TypeIdentifier> <type_parameters:(TypeParameters)?> <equal_token:EQUAL_TOKEN> <dart_type:Type> <semicolon_token:SEMICOLON_TOKEN> => TypeAliasTypeIdentifier{<>}};

pub TypeAliasFunctionTypeAlias: TypeAliasFunctionTypeAlias = {<typedef_token:TYPEDEF_TOKEN> <function_type_alias:FunctionTypeAlias> => TypeAliasFunctionTypeAlias{<>}};

pub TypeAlias: TypeAlias = {TypeAliasTypeIdentifier => TypeAlias::TypeIdentifier(<>), TypeAliasFunctionTypeAlias => TypeAlias::FunctionTypeAlias(<>)};

pub FunctionTypeAlias: FunctionTypeAlias = {<function_prefix:FunctionPrefix> <formal_parameter_part:FormalParameterPart> <semicolon_token:SEMICOLON_TOKEN> => FunctionTypeAlias{<>}};

pub FunctionPrefix: FunctionPrefix = {<dart_type:(Type)?> <identifier:Identifier> => FunctionPrefix{<>}};

pub Comment: Comment = {SINGLE_LINE_COMMENT => Comment::SingleLineComment(<>), MULTI_LINE_COMMENT => Comment::MultiLineComment(<>)};

pub NUMBER: null = {(DIGIT)+ (PERIOD_TOKEN (DIGIT)+)? (EXPONENT)?, PERIOD_TOKEN (DIGIT)+ (EXPONENT)?};

pub EXPONENT: null = {EXPONENT_TOKEN, SCIENTIFIC_TOKEN (PLUS_TOKEN, MINUS_TOKEN)? (DIGIT)+};

pub HEX_NUMBER: null = {HEX0X_TOKEN (HEX_DIGIT)+, HEX0_X_TOKEN (HEX_DIGIT)+};

pub HEX_DIGIT: null = {r"[a-f]", r"[A-F]", DIGIT};

pub RAW_SINGLE_LINE_STRING: null = {R_TOKEN QUOTE_TOKEN (!(QUOTE_TOKEN, R_ESCAPE_TOKEN, NEWLINE_TOKEN)* QUOTE_TOKEN, R_TOKEN DOUBLE_QUOTE_TOKEN (!(DOUBLE_QUOTE_TOKEN, R_ESCAPE_TOKEN, NEWLINE_TOKEN)* DOUBLE_QUOTE_TOKEN};

pub STRING_CONTENT_COMMON: null = {!(BACK_TOKEN, QUOTE_TOKEN, DOUBLE_QUOTE_TOKEN, DOLLAR_TOKEN, R_ESCAPE_TOKEN, NEWLINE_TOKEN, ESCAPE_SEQUENCE, BACK_TOKEN !(N_TOKEN, R_TOKEN, B_TOKEN, T_TOKEN, V_TOKEN, X_TOKEN, U_TOKEN, R_ESCAPE_TOKEN, NEWLINE_TOKEN, SIMPLE_STRING_INTERPOLATION};

pub STRING_CONTENT_SQ: null = {STRING_CONTENT_COMMON, DOUBLE_QUOTE_TOKEN};

pub SINGLE_LINE_STRING_SQ_BEGIN_END: null = {QUOTE_TOKEN (STRING_CONTENT_SQ)* QUOTE_TOKEN};

pub SINGLE_LINE_STRING_SQ_BEGIN_MID: null = {QUOTE_TOKEN (STRING_CONTENT_SQ)* INTERPOLATION_START_TOKEN};

pub SINGLE_LINE_STRING_SQ_MID_MID: null = {CLOSE_CURLY_BRACKET_TOKEN (STRING_CONTENT_SQ)* INTERPOLATION_START_TOKEN};

pub SINGLE_LINE_STRING_SQ_MID_END: null = {CLOSE_CURLY_BRACKET_TOKEN (STRING_CONTENT_SQ)* QUOTE_TOKEN};

pub STRING_CONTENT_DQ: null = {STRING_CONTENT_COMMON, QUOTE_TOKEN};

pub SINGLE_LINE_STRING_DQ_BEGIN_END: null = {DOUBLE_QUOTE_TOKEN (STRING_CONTENT_DQ)* DOUBLE_QUOTE_TOKEN};

pub SINGLE_LINE_STRING_DQ_BEGIN_MID: null = {DOUBLE_QUOTE_TOKEN (STRING_CONTENT_DQ)* INTERPOLATION_START_TOKEN};

pub SINGLE_LINE_STRING_DQ_MID_MID: null = {CLOSE_CURLY_BRACKET_TOKEN (STRING_CONTENT_DQ)* INTERPOLATION_START_TOKEN};

pub SINGLE_LINE_STRING_DQ_MID_END: null = {CLOSE_CURLY_BRACKET_TOKEN (STRING_CONTENT_DQ)* DOUBLE_QUOTE_TOKEN};

pub RAW_MULTI_LINE_STRING: null = {R_TOKEN TRIPLE_QUOTES_TOKEN ANY TRIPLE_QUOTES_TOKEN, R_TOKEN TRIPLE_DOUBLE_QUOTES_TOKEN ANY TRIPLE_DOUBLE_QUOTES_TOKEN};

pub QUOTES_SQ: null = {QUOTE_TOKEN, TWO_QUOTES_TOKEN};

pub STRING_CONTENT_TSQ: null = {(QUOTES_SQ)? STRING_CONTENT_COMMON, DOUBLE_QUOTE_TOKEN, R_ESCAPE_TOKEN, NEWLINE_TOKEN};

pub MULTI_LINE_STRING_SQ_BEGIN_END: null = {TRIPLE_QUOTES_TOKEN (STRING_CONTENT_TSQ)* TRIPLE_QUOTES_TOKEN};

pub MULTI_LINE_STRING_SQ_BEGIN_MID: null = {TRIPLE_QUOTES_TOKEN (STRING_CONTENT_TSQ)* (QUOTES_SQ)? INTERPOLATION_START_TOKEN};

pub MULTI_LINE_STRING_SQ_MID_MID: null = {CLOSE_CURLY_BRACKET_TOKEN (STRING_CONTENT_TSQ)* (QUOTES_SQ)? INTERPOLATION_START_TOKEN};

pub MULTI_LINE_STRING_SQ_MID_END: null = {CLOSE_CURLY_BRACKET_TOKEN (STRING_CONTENT_TSQ)* TRIPLE_QUOTES_TOKEN};

pub QUOTES_DQ: null = {DOUBLE_QUOTE_TOKEN, TWO_DOUBLE_QUOTES_TOKEN};

pub STRING_CONTENT_TDQ: null = {(QUOTES_DQ)? STRING_CONTENT_COMMON, QUOTE_TOKEN, R_ESCAPE_TOKEN, NEWLINE_TOKEN};

pub MULTI_LINE_STRING_DQ_BEGIN_END: null = {TRIPLE_DOUBLE_QUOTES_TOKEN (STRING_CONTENT_TDQ)* TRIPLE_DOUBLE_QUOTES_TOKEN};

pub MULTI_LINE_STRING_DQ_BEGIN_MID: null = {TRIPLE_DOUBLE_QUOTES_TOKEN (STRING_CONTENT_TDQ)* (QUOTES_DQ)? INTERPOLATION_START_TOKEN};

pub MULTI_LINE_STRING_DQ_MID_MID: null = {CLOSE_CURLY_BRACKET_TOKEN (STRING_CONTENT_TDQ)* (QUOTES_DQ)? INTERPOLATION_START_TOKEN};

pub MULTI_LINE_STRING_DQ_MID_END: null = {CLOSE_CURLY_BRACKET_TOKEN (STRING_CONTENT_TDQ)* TRIPLE_DOUBLE_QUOTES_TOKEN};

pub ESCAPE_SEQUENCE: null = {NEWLINE_TOKEN, R_ESCAPE_TOKEN, F_ESCAPE_TOKEN, B_ESCAPE_TOKEN, T_ESCAPE_TOKEN, V_ESCAPE_TOKEN, X_ESCAPE_TOKEN HEX_DIGIT HEX_DIGIT, U_ESCAPE_TOKEN HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT, U_BRACKET_ESCAPE_TOKEN HEX_DIGIT_SEQUENCE CLOSE_CURLY_BRACKET_TOKEN};

pub HEX_DIGIT_SEQUENCE: null = {HEX_DIGIT (HEX_DIGIT)? (HEX_DIGIT)? (HEX_DIGIT)? (HEX_DIGIT)? (HEX_DIGIT)?};

pub NEWLINE: null = {NEWLINE_TOKEN, R_ESCAPE_TOKEN, RN_ESCAPE_TOKEN};

pub SIMPLE_STRING_INTERPOLATION: null = {DOLLAR_TOKEN IDENTIFIER_NO_DOLLAR, BUILT_IN_IDENTIFIER, THIS_TOKEN};

pub BUILT_IN_IDENTIFIER: null = {ABSTRACT_TOKEN, AS_TOKEN, COVARIANT_TOKEN, DEFERRED_TOKEN, DYNAMIC_TOKEN, EXPORT_TOKEN, EXTERNAL_TOKEN, EXTENSION_TOKEN, FACTORY_TOKEN, FUNCTION_TOKEN, GET_TOKEN, IMPLEMENTS_TOKEN, IMPORT_TOKEN, INTERFACE_TOKEN, LATE_TOKEN, LIBRARY_TOKEN, MIXIN_TOKEN, OPERATOR_TOKEN, PART_TOKEN, REQUIRED_TOKEN, SET_TOKEN, STATIC_TOKEN, TYPEDEF_TOKEN};

pub OTHER_IDENTIFIER: null = {ASYNC_TOKEN, HIDE_TOKEN, OF_TOKEN, ON_TOKEN, SHOW_TOKEN, SYNC_TOKEN, AWAIT_TOKEN, YIELD_TOKEN};

pub IDENTIFIER_NO_DOLLAR: null = {IDENTIFIER_START_NO_DOLLAR (IDENTIFIER_PART_NO_DOLLAR)*};

pub IDENTIFIER_START_NO_DOLLAR: null = {LETTER, UNDERSCORE_TOKEN};

pub IDENTIFIER_PART_NO_DOLLAR: null = {IDENTIFIER_START_NO_DOLLAR, DIGIT};

pub IDENTIFIER: null = {IDENTIFIER_START (IDENTIFIER_PART)*};

pub IDENTIFIER_START: null = {IDENTIFIER_START_NO_DOLLAR, DOLLAR_TOKEN};

pub IDENTIFIER_PART: null = {IDENTIFIER_START, DIGIT};

pub LETTER: null = {r"[a-z]", r"[A-Z]"};

pub DIGIT: null = {r"[0-9]"};

pub WHITESPACE: null = {(T_ESCAPE_TOKEN, SPACE_TOKEN, NEWLINE)+};

pub SCRIPT_TAG_CONTENT: null = {(!(NEWLINE)*};

pub RESERVED_WORD: null = {ASSERT_TOKEN, BREAK_TOKEN, CASE_TOKEN, CATCH_TOKEN, CLASS_TOKEN, CONST_TOKEN, CONTINUE_TOKEN, DEFAULT_TOKEN, DO_TOKEN, ELSE_TOKEN, ENUM_TOKEN, EXTENDS_TOKEN, FALSE_TOKEN, FINAL_TOKEN, FINALLY_TOKEN, FOR_TOKEN, IF_TOKEN, IN_TOKEN, IS_TOKEN, NEW_TOKEN, NULL_TOKEN, RETHROW_TOKEN, RETURN_TOKEN, SUPER_TOKEN, SWITCH_TOKEN, THIS_TOKEN, THROW_TOKEN, TRUE_TOKEN, TRY_TOKEN, VAR_TOKEN, VOID_TOKEN, WHILE_TOKEN, WITH_TOKEN};

pub SINGLE_LINE_COMMENT: null = {COMMENT_TOKEN (!(NEWLINE)* (NEWLINE)?};

pub MULTI_LINE_COMMENT: null = {COMMENT_MULTILINE_START_TOKEN (MULTI_LINE_COMMENT, !(COMMENT_MULTILINE_END_TOKEN)* COMMENT_MULTILINE_END_TOKEN};

pub COMMENT: null = {SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT};

pub LET_TOKEN:Token = {<start:@L> <text:let> <end:@R> => Token(<>)};

pub IN_TOKEN:Token = {<start:@L> <text:in> <end:@R> => Token(<>)};

pub LATE_TOKEN:Token = {<start:@L> <text:late> <end:@R> => Token(<>)};

pub FINAL_TOKEN:Token = {<start:@L> <text:final> <end:@R> => Token(<>)};

pub CONST_TOKEN:Token = {<start:@L> <text:const> <end:@R> => Token(<>)};

pub VAR_TOKEN:Token = {<start:@L> <text:var> <end:@R> => Token(<>)};

pub EQUAL_TOKEN:Token = {<start:@L> <text:=> <end:@R> => Token(<>)};

pub COMMA_TOKEN:Token = {<start:@L> <text:,> <end:@R> => Token(<>)};

pub ASYNC_TOKEN:Token = {<start:@L> <text:async> <end:@R> => Token(<>)};

pub ARROW_TOKEN:Token = {<start:@L> <text:=>> <end:@R> => Token(<>)};

pub SEMICOLON_TOKEN:Token = {<start:@L> <text:;> <end:@R> => Token(<>)};

pub ASTERISK_TOKEN:Token = {<start:@L> <text:*> <end:@R> => Token(<>)};

pub SYNC_TOKEN:Token = {<start:@L> <text:sync> <end:@R> => Token(<>)};

pub OPEN_CURLY_BRACKET_TOKEN:Token = {<start:@L> <text:{> <end:@R> => Token(<>)};

pub CLOSE_CURLY_BRACKET_TOKEN:Token = {<start:@L> <text:}> <end:@R> => Token(<>)};

pub OPEN_PAREN_TOKEN:Token = {<start:@L> <text:(> <end:@R> => Token(<>)};

pub CLOSE_PAREN_TOKEN:Token = {<start:@L> <text:)> <end:@R> => Token(<>)};

pub OPEN_SQUARE_BRACKET_TOKEN:Token = {<start:@L> <text:[> <end:@R> => Token(<>)};

pub CLOSE_SQUARE_BRACKET_TOKEN:Token = {<start:@L> <text:]> <end:@R> => Token(<>)};

pub COVARIANT_TOKEN:Token = {<start:@L> <text:covariant> <end:@R> => Token(<>)};

pub QUESTION_TOKEN:Token = {<start:@L> <text:?> <end:@R> => Token(<>)};

pub THIS_TOKEN:Token = {<start:@L> <text:this> <end:@R> => Token(<>)};

pub PERIOD_TOKEN:Token = {<start:@L> <text:.> <end:@R> => Token(<>)};

pub SUPER_TOKEN:Token = {<start:@L> <text:super> <end:@R> => Token(<>)};

pub COLON_TOKEN:Token = {<start:@L> <text::> <end:@R> => Token(<>)};

pub REQUIRED_TOKEN:Token = {<start:@L> <text:required> <end:@R> => Token(<>)};

pub ABSTRACT_TOKEN:Token = {<start:@L> <text:abstract> <end:@R> => Token(<>)};

pub CLASS_TOKEN:Token = {<start:@L> <text:class> <end:@R> => Token(<>)};

pub STATIC_TOKEN:Token = {<start:@L> <text:static> <end:@R> => Token(<>)};

pub EXTERNAL_TOKEN:Token = {<start:@L> <text:external> <end:@R> => Token(<>)};

pub OPERATOR_TOKEN:Token = {<start:@L> <text:operator> <end:@R> => Token(<>)};

pub TILDE_TOKEN:Token = {<start:@L> <text:~> <end:@R> => Token(<>)};

pub SQUARE_BRACKETS_TOKEN:Token = {<start:@L> <text:[]> <end:@R> => Token(<>)};

pub SQUARE_BRACKETS_EQ_TOKEN:Token = {<start:@L> <text:[]=> <end:@R> => Token(<>)};

pub DOUBLE_EQUAL_TOKEN:Token = {<start:@L> <text:==> <end:@R> => Token(<>)};

pub GET_TOKEN:Token = {<start:@L> <text:get> <end:@R> => Token(<>)};

pub SET_TOKEN:Token = {<start:@L> <text:set> <end:@R> => Token(<>)};

pub FACTORY_TOKEN:Token = {<start:@L> <text:factory> <end:@R> => Token(<>)};

pub EXTENDS_TOKEN:Token = {<start:@L> <text:extends> <end:@R> => Token(<>)};

pub WITH_TOKEN:Token = {<start:@L> <text:with> <end:@R> => Token(<>)};

pub IMPLEMENTS_TOKEN:Token = {<start:@L> <text:implements> <end:@R> => Token(<>)};

pub ON_TOKEN:Token = {<start:@L> <text:on> <end:@R> => Token(<>)};

pub MIXIN_TOKEN:Token = {<start:@L> <text:mixin> <end:@R> => Token(<>)};

pub EXTENSION_TOKEN:Token = {<start:@L> <text:extension> <end:@R> => Token(<>)};

pub ENUM_TOKEN:Token = {<start:@L> <text:enum> <end:@R> => Token(<>)};

pub LESS_TOKEN:Token = {<start:@L> <text:<> <end:@R> => Token(<>)};

pub MORE_TOKEN:Token = {<start:@L> <text:>> <end:@R> => Token(<>)};

pub AT_TOKEN:Token = {<start:@L> <text:@> <end:@R> => Token(<>)};

pub NULL_TOKEN:Token = {<start:@L> <text:null> <end:@R> => Token(<>)};

pub TRUE_TOKEN:Token = {<start:@L> <text:true> <end:@R> => Token(<>)};

pub FALSE_TOKEN:Token = {<start:@L> <text:false> <end:@R> => Token(<>)};

pub INTERPOLATION_START_TOKEN:Token = {<start:@L> <text:${> <end:@R> => Token(<>)};

pub VOID_TOKEN:Token = {<start:@L> <text:void> <end:@R> => Token(<>)};

pub HASH_TOKEN:Token = {<start:@L> <text:#> <end:@R> => Token(<>)};

pub POINTS_EXPAND_TOKEN:Token = {<start:@L> <text:...> <end:@R> => Token(<>)};

pub POINTS_EXPAND_QUESTION_TOKEN:Token = {<start:@L> <text:...?> <end:@R> => Token(<>)};

pub ELSE_TOKEN:Token = {<start:@L> <text:else> <end:@R> => Token(<>)};

pub IF_TOKEN:Token = {<start:@L> <text:if> <end:@R> => Token(<>)};

pub AWAIT_TOKEN:Token = {<start:@L> <text:await> <end:@R> => Token(<>)};

pub FOR_TOKEN:Token = {<start:@L> <text:for> <end:@R> => Token(<>)};

pub NEW_TOKEN:Token = {<start:@L> <text:new> <end:@R> => Token(<>)};

pub THROW_TOKEN:Token = {<start:@L> <text:throw> <end:@R> => Token(<>)};

pub POINTS_ID_TOKEN:Token = {<start:@L> <text:..> <end:@R> => Token(<>)};

pub POINTS_ID_QUESTION_TOKEN:Token = {<start:@L> <text:?..> <end:@R> => Token(<>)};

pub TIMES_EQUAL_TOKEN:Token = {<start:@L> <text:*=> <end:@R> => Token(<>)};

pub DIV_EQUAL_TOKEN:Token = {<start:@L> <text:/=> <end:@R> => Token(<>)};

pub INTEGER_DIV_EQUAL_TOKEN:Token = {<start:@L> <text:~/=> <end:@R> => Token(<>)};

pub MODULE_EQUAL_TOKEN:Token = {<start:@L> <text:%=> <end:@R> => Token(<>)};

pub PLUS_EQUAL_TOKEN:Token = {<start:@L> <text:+=> <end:@R> => Token(<>)};

pub MINUS_EQUAL_TOKEN:Token = {<start:@L> <text:-=> <end:@R> => Token(<>)};

pub BIT_LEFT_EQUAL_TOKEN:Token = {<start:@L> <text:<<=> <end:@R> => Token(<>)};

pub BIT_RIGHT0_EQUAL_TOKEN:Token = {<start:@L> <text:>>>=> <end:@R> => Token(<>)};

pub BIT_RIGHT_EQUAL_TOKEN:Token = {<start:@L> <text:>>=> <end:@R> => Token(<>)};

pub BIT_AND_EUQAL_TOKEN:Token = {<start:@L> <text:&=> <end:@R> => Token(<>)};

pub BIT_NEG_EQUAL_TOKEN:Token = {<start:@L> <text:^=> <end:@R> => Token(<>)};

pub BIT_XOR_EQUAL_TOKEN:Token = {<start:@L> <text:|=> <end:@R> => Token(<>)};

pub QUESTION_QUESTION_EQUAL_TOKEN:Token = {<start:@L> <text:??=> <end:@R> => Token(<>)};

pub QUESTION_QUESTION_TOKEN:Token = {<start:@L> <text:??> <end:@R> => Token(<>)};

pub OR_TOKEN:Token = {<start:@L> <text:||> <end:@R> => Token(<>)};

pub AND_TOKEN:Token = {<start:@L> <text:&&> <end:@R> => Token(<>)};

pub NOT_EQUAL_TOKEN:Token = {<start:@L> <text:!=> <end:@R> => Token(<>)};

pub MORE_OR_EQUAL_TOKEN:Token = {<start:@L> <text:>=> <end:@R> => Token(<>)};

pub LESS_OR_EQUAL_TOKEN:Token = {<start:@L> <text:<=> <end:@R> => Token(<>)};

pub BIT_XOR_TOKEN:Token = {<start:@L> <text:|> <end:@R> => Token(<>)};

pub BIT_NEG_TOKEN:Token = {<start:@L> <text:^> <end:@R> => Token(<>)};

pub BIT_AND_TOKEN:Token = {<start:@L> <text:&> <end:@R> => Token(<>)};

pub BIT_LEFT_TOKEN:Token = {<start:@L> <text:<<> <end:@R> => Token(<>)};

pub BIT_RIGHT0_TOKEN:Token = {<start:@L> <text:>>>> <end:@R> => Token(<>)};

pub BIT_RIGHT_TOKEN:Token = {<start:@L> <text:>>> <end:@R> => Token(<>)};

pub PLUS_TOKEN:Token = {<start:@L> <text:+> <end:@R> => Token(<>)};

pub MINUS_TOKEN:Token = {<start:@L> <text:-> <end:@R> => Token(<>)};

pub DIVIDE_TOKEN:Token = {<start:@L> <text:/> <end:@R> => Token(<>)};

pub MODULUS_TOKEN:Token = {<start:@L> <text:%> <end:@R> => Token(<>)};

pub INTEGER_DIV_TOKEN:Token = {<start:@L> <text:~/> <end:@R> => Token(<>)};

pub EXCLAMATION_TOKEN:Token = {<start:@L> <text:!> <end:@R> => Token(<>)};

pub PLUS_PLUS_TOKEN:Token = {<start:@L> <text:++> <end:@R> => Token(<>)};

pub MINUS_MINUS_TOKEN:Token = {<start:@L> <text:--> <end:@R> => Token(<>)};

pub QUESTION_ID_TOKEN:Token = {<start:@L> <text:?.> <end:@R> => Token(<>)};

pub DYNAMIC_TOKEN:Token = {<start:@L> <text:dynamic> <end:@R> => Token(<>)};

pub IS_TOKEN:Token = {<start:@L> <text:is> <end:@R> => Token(<>)};

pub AS_TOKEN:Token = {<start:@L> <text:as> <end:@R> => Token(<>)};

pub WHILE_TOKEN:Token = {<start:@L> <text:while> <end:@R> => Token(<>)};

pub DO_TOKEN:Token = {<start:@L> <text:do> <end:@R> => Token(<>)};

pub SWITCH_TOKEN:Token = {<start:@L> <text:switch> <end:@R> => Token(<>)};

pub CASE_TOKEN:Token = {<start:@L> <text:case> <end:@R> => Token(<>)};

pub DEFAULT_TOKEN:Token = {<start:@L> <text:default> <end:@R> => Token(<>)};

pub RETHROW_TOKEN:Token = {<start:@L> <text:rethrow> <end:@R> => Token(<>)};

pub TRY_TOKEN:Token = {<start:@L> <text:try> <end:@R> => Token(<>)};

pub CATCH_TOKEN:Token = {<start:@L> <text:catch> <end:@R> => Token(<>)};

pub FINALLY_TOKEN:Token = {<start:@L> <text:finally> <end:@R> => Token(<>)};

pub RETURN_TOKEN:Token = {<start:@L> <text:return> <end:@R> => Token(<>)};

pub BREAK_TOKEN:Token = {<start:@L> <text:break> <end:@R> => Token(<>)};

pub CONTINUE_TOKEN:Token = {<start:@L> <text:continue> <end:@R> => Token(<>)};

pub YIELD_TOKEN:Token = {<start:@L> <text:yield> <end:@R> => Token(<>)};

pub ASSERT_TOKEN:Token = {<start:@L> <text:assert> <end:@R> => Token(<>)};

pub HASH_EXCLAMATION_TOKEN:Token = {<start:@L> <text:#!> <end:@R> => Token(<>)};

pub LIBRARY_TOKEN:Token = {<start:@L> <text:library> <end:@R> => Token(<>)};

pub DEFERRED_TOKEN:Token = {<start:@L> <text:deferred> <end:@R> => Token(<>)};

pub IMPORT_TOKEN:Token = {<start:@L> <text:import> <end:@R> => Token(<>)};

pub EXPORT_TOKEN:Token = {<start:@L> <text:export> <end:@R> => Token(<>)};

pub SHOW_TOKEN:Token = {<start:@L> <text:show> <end:@R> => Token(<>)};

pub HIDE_TOKEN:Token = {<start:@L> <text:hide> <end:@R> => Token(<>)};

pub PART_TOKEN:Token = {<start:@L> <text:part> <end:@R> => Token(<>)};

pub OF_TOKEN:Token = {<start:@L> <text:of> <end:@R> => Token(<>)};

pub FUNCTION_TOKEN:Token = {<start:@L> <text:Function> <end:@R> => Token(<>)};

pub TYPEDEF_TOKEN:Token = {<start:@L> <text:typedef> <end:@R> => Token(<>)};

pub EXPONENT_TOKEN:Token = {<start:@L> <text:e> <end:@R> => Token(<>)};

pub SCIENTIFIC_TOKEN:Token = {<start:@L> <text:E> <end:@R> => Token(<>)};

pub HEX0X_TOKEN:Token = {<start:@L> <text:0x> <end:@R> => Token(<>)};

pub HEX0_X_TOKEN:Token = {<start:@L> <text:0X> <end:@R> => Token(<>)};

pub R_TOKEN:Token = {<start:@L> <text:r> <end:@R> => Token(<>)};

pub QUOTE_TOKEN:Token = {<start:@L> <text:\'> <end:@R> => Token(<>)};

pub R_ESCAPE_TOKEN:Token = {<start:@L> <text:\r> <end:@R> => Token(<>)};

pub NEWLINE_TOKEN:Token = {<start:@L> <text:\n> <end:@R> => Token(<>)};

pub DOUBLE_QUOTE_TOKEN:Token = {<start:@L> <text:"> <end:@R> => Token(<>)};

pub BACK_TOKEN:Token = {<start:@L> <text:\\> <end:@R> => Token(<>)};

pub DOLLAR_TOKEN:Token = {<start:@L> <text:$> <end:@R> => Token(<>)};

pub N_TOKEN:Token = {<start:@L> <text:n> <end:@R> => Token(<>)};

pub B_TOKEN:Token = {<start:@L> <text:b> <end:@R> => Token(<>)};

pub T_TOKEN:Token = {<start:@L> <text:t> <end:@R> => Token(<>)};

pub V_TOKEN:Token = {<start:@L> <text:v> <end:@R> => Token(<>)};

pub X_TOKEN:Token = {<start:@L> <text:x> <end:@R> => Token(<>)};

pub U_TOKEN:Token = {<start:@L> <text:u> <end:@R> => Token(<>)};

pub TRIPLE_QUOTES_TOKEN:Token = {<start:@L> <text:\'\'\'> <end:@R> => Token(<>)};

pub TRIPLE_DOUBLE_QUOTES_TOKEN:Token = {<start:@L> <text:"""> <end:@R> => Token(<>)};

pub TWO_QUOTES_TOKEN:Token = {<start:@L> <text:\'\'> <end:@R> => Token(<>)};

pub TWO_DOUBLE_QUOTES_TOKEN:Token = {<start:@L> <text:""> <end:@R> => Token(<>)};

pub F_ESCAPE_TOKEN:Token = {<start:@L> <text:\f> <end:@R> => Token(<>)};

pub B_ESCAPE_TOKEN:Token = {<start:@L> <text:\b> <end:@R> => Token(<>)};

pub T_ESCAPE_TOKEN:Token = {<start:@L> <text:\t> <end:@R> => Token(<>)};

pub V_ESCAPE_TOKEN:Token = {<start:@L> <text:\v> <end:@R> => Token(<>)};

pub X_ESCAPE_TOKEN:Token = {<start:@L> <text:\x> <end:@R> => Token(<>)};

pub U_ESCAPE_TOKEN:Token = {<start:@L> <text:\u> <end:@R> => Token(<>)};

pub U_BRACKET_ESCAPE_TOKEN:Token = {<start:@L> <text:\u{> <end:@R> => Token(<>)};

pub RN_ESCAPE_TOKEN:Token = {<start:@L> <text:\r\n> <end:@R> => Token(<>)};

pub INTERFACE_TOKEN:Token = {<start:@L> <text:interface> <end:@R> => Token(<>)};

pub UNDERSCORE_TOKEN:Token = {<start:@L> <text:_> <end:@R> => Token(<>)};

pub SPACE_TOKEN:Token = {<start:@L> <text: > <end:@R> => Token(<>)};

pub COMMENT_TOKEN:Token = {<start:@L> <text://> <end:@R> => Token(<>)};

pub COMMENT_MULTILINE_START_TOKEN:Token = {<start:@L> <text:/*> <end:@R> => Token(<>)};

pub COMMENT_MULTILINE_END_TOKEN:Token = {<start:@L> <text:*/> <end:@R> => Token(<>)};